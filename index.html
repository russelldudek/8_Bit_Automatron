<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>8-Bit Automatron</title>
<style>
  body {
    font-family: monospace;
    background:#222;
    color:#eee;
    margin:0;
    padding:0;
    min-height:100vh;
    width:100%;
    overflow-x:hidden;
    display:flex;
    flex-direction:column;
  }
  #toolbar-top, #toolbar-bottom {
    padding:10px;
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    justify-content:center;
    align-items:center;
    background:#111;
    z-index:2;
  }
  #toolbar-bottom { padding-top:0; flex-direction:column; }

  .toolbar-row {
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    justify-content:center;
    width:100%;
  }

  canvas {
    image-rendering: pixelated;
    background:transparent;
    cursor:crosshair;
  }

  .control {
    background:#333;
    padding:6px 10px;
    border-radius:4px;
    color:#fff;
    border:1px solid #555;
    display:flex;
    align-items:center;
    justify-content:center;
    min-height:36px;
    height:36px;
    min-width:160px;
    box-sizing:border-box;
    font-size:0.9rem;
  }
  .control input,
  .control select {
    font-family:inherit;
    font-size:0.9rem;
    margin-left:6px;
    height:24px;
  }

  .button-control {
    cursor:pointer;
    background:#333;
    border:1px solid #555;
    border-radius:4px;
    padding:6px 10px;
    color:#fff;
    min-height:36px;
    min-width:160px;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .button-control:hover { background:#444; }
  .button-control:active { background:#0a0; border-color:#0f0; }
  .button-control.active {
    background:#225;
    border-color:#4af;
  }

  .color-input {
    margin-left:6px;
    height:28px;
    width:60px;
    border:none;
    background:transparent;
    cursor:pointer;
  }

  #zoomControls {
    display:flex;
    justify-content:center;
    align-items:center;
    gap:10px;
    margin-bottom:16px;
  }

  #zoomControls button {
    width:40px;
    height:32px;
    font-size:1.2rem;
    cursor:pointer;
    background:#333;
    border:1px solid #555;
    border-radius:4px;
    color:#fff;
  }

  #zoomDisplay {
    min-width:60px;
    text-align:center;
  }

  #canvasWrapper {
    flex:1;
    display:flex;
    justify-content:center;
    align-items:center;
    padding:20px;
    box-sizing:border-box;
    overflow:auto;
  }

  #canvasContainer {
    position:relative;
    display:inline-block;
    border:2px solid #666;
  }

  #canvasContainer canvas {
    display:block;
  }

  #gridOverlay,
  #cursorOverlay {
    position:absolute;
    top:0;
    left:0;
    pointer-events:none;
  }

  #gridOverlay {
    background-image:
      linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
      linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
    background-repeat:repeat;
    box-sizing:border-box;
    z-index:1;
  }

  #cursorOverlay {
    border:2px solid #0ff;
    box-sizing:border-box;
    z-index:2;
    background:rgba(0,255,255,0.12);
  }


  @media (max-width: 900px) {
    body {
      align-items:stretch;
    }

    #toolbar-top, #toolbar-bottom {
      flex-direction:column;
      align-items:stretch;
      gap:12px;
    }

    .toolbar-row {
      flex-direction:column;
      align-items:stretch;
      gap:12px;
    }

    .control,
    .button-control {
      width:100%;
      min-width:0;
    }

    .control {
      flex-direction:column;
      align-items:flex-start;
      gap:6px;
    }

    .control input,
    .control select {
      margin-left:0;
      width:100%;
      min-width:0;
    }

    #canvasWrapper {
      padding:12px;
    }

    #canvasContainer {
      max-width:100%;
    }

    h2 {
      font-size:1.5rem;
      padding:0 12px;
    }

  }
</style>
</head>
<body>
<h2 style="margin:8px 0; text-align:center; width:100%;">8-Bit Automatron</h2>

<div id="toolbar-top">
  <div class="control">Pixel Size: <input type="number" id="pixelSize" value="200" min="1" max="1024" style="width:4em;"></div>
  <div class="control">Aspect Ratio:
    <select id="aspect">
      <option value="1:1">1:1</option>
      <option value="4:3">4:3</option>
      <option value="3:4">3:4</option>
      <option value="16:9">16:9</option>
      <option value="4:1">Banner</option>
    </select>
  </div>
  <div class="control">Zoom: <input type="number" id="zoomLevel" value="4" min="1" max="32" style="width:4em;"></div>
  <div class="control">Background:
    <input type="color" id="bgColorInput" class="color-input" value="#000000">
    <label style="margin-left:8px;"><input type="checkbox" id="transparentBg" checked> Transparent</label>
  </div>
  <div class="control">Pen Size: <input id="penSize" type="number" value="4" min="1" max="20" style="width:4em;"></div>
  <div class="control">Pen Color:
    <input type="color" id="penColorInput" class="color-input" value="#ffffff">
    <label style="margin-left:8px;"><input type="checkbox" id="penEraser"> Erase</label>
  </div>
  <div class="control">Draw Mode:
    <select id="drawingMode">
      <option value="pen">Freehand</option>
      <option value="rectangle">Rectangle</option>
      <option value="circle">Circle</option>
      <option value="triangle">Triangle</option>
    </select>
    <label style="margin-left:8px;"><input type="checkbox" id="shapeFillToggle" checked> Fill Shapes</label>
  </div>
  </div>
</div>

<div id="toolbar-bottom">
  <div class="toolbar-row">
    <button id="undoBtn" class="button-control">Undo</button>
    <button id="resetBtn" class="button-control">Reset</button>
  </div>
  <div class="toolbar-row">
    <button id="uploadBtn" class="button-control">Upload PNG</button>
    <input type="file" id="uploadInput" accept="image/png" style="display:none;">
    <button id="bitifyBtn" class="button-control">8-Bitify</button>
    <button id="colorPickerTool" class="button-control" title="Pick a color from the canvas">Pick Color</button>
    <button id="exportBtn" class="button-control">Export PNG</button>
    <div class="control" style="min-width:200px;">
      File Name: <input type="text" id="fileNameInput" value="design" style="margin-left:6px; width:120px;">
    </div>
  </div>
</div>

<div id="canvasWrapper">
  <div id="canvasContainer">
    <canvas id="canvas"></canvas>
    <div id="gridOverlay"></div>
    <div id="cursorOverlay"></div>
  </div>
</div>

<div id="zoomControls">
  <button id="zoomOutBtn">-</button>
  <div id="zoomDisplay">100%</div>
  <button id="zoomInBtn">+</button>
</div>

<script>
// =====================
// Canvas + Drawing Core
// =====================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

const pixelSizeInput = document.getElementById('pixelSize');
const aspectSelect = document.getElementById('aspect');
const bgColorInput = document.getElementById('bgColorInput');
const transparentToggle = document.getElementById('transparentBg');
const penSizeInput = document.getElementById('penSize');
const penColorInput = document.getElementById('penColorInput');
const penEraserToggle = document.getElementById('penEraser');
const uploadBtn = document.getElementById('uploadBtn');
const uploadInput = document.getElementById('uploadInput');
const bitifyBtn = document.getElementById('bitifyBtn');
const zoomInput = document.getElementById('zoomLevel');
const fileNameInput = document.getElementById('fileNameInput');
const colorPickerToolBtn = document.getElementById('colorPickerTool');
const drawingModeSelect = document.getElementById('drawingMode');
const shapeFillToggle = document.getElementById('shapeFillToggle');
const canvasContainer = document.getElementById('canvasContainer');
const gridOverlayEl = document.getElementById('gridOverlay');
const cursorOverlayEl = document.getElementById('cursorOverlay');
let baseSize = 200;
const maxSize = 1024;
let gridW = baseSize;
let gridH = baseSize;
let zoomLevel = 1;
const minZoom = 0.5;
const maxZoom = 8;

let drawing = false;
let penSize = 4;
let penColor = penColorInput ? penColorInput.value : '#ffffff';
let historyStack = [];
let uploadedImage = null;
let zoom = clamp(parseInt(zoomInput.value, 10) || 1, 1, 32);
zoomInput.value = zoom;
let cursorX = 0;
let cursorY = 0;
let pickColorMode = false;
let drawingMode = drawingModeSelect ? drawingModeSelect.value : 'pen';
let fillShapes = shapeFillToggle ? shapeFillToggle.checked : true;
let shapeStart = null;
let shapeCurrent = null;
let shapeSnapshot = null;
let eraserMode = penEraserToggle ? penEraserToggle.checked : false;

if (drawingModeSelect) {
  drawingModeSelect.addEventListener('change', e => {
    drawingMode = e.target.value;
  });
}

if (shapeFillToggle) {
  shapeFillToggle.addEventListener('change', e => {
    fillShapes = e.target.checked;
  });
}

if (penEraserToggle) {
  penEraserToggle.addEventListener('change', e => {
    eraserMode = e.target.checked;
    updateCursorOverlayAppearance();
  });
}

function clamp(val,min,max){return Math.max(min,Math.min(max,val));}

function normalizeHex(hex){
  if (typeof hex !== 'string') return '#000000';
  let value = hex.trim();
  if (!value) return '#000000';
  if (value[0] === '#') value = value.slice(1);
  if (/^[0-9a-f]{3}$/i.test(value)) {
    value = value.split('').map(ch => ch + ch).join('');
  }
  if (!/^[0-9a-f]{6}$/i.test(value)) {
    return '#000000';
  }
  return '#' + value.toLowerCase();
}

function clearCanvasContents(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (!transparentToggle.checked) {
    ctx.fillStyle = bgColorInput.value;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
}

function updateCursorOverlayPosition(){
  if (!cursorOverlayEl) return;
  const maxX = Math.max(0, canvas.width - penSize);
  const maxY = Math.max(0, canvas.height - penSize);
  cursorX = clamp(cursorX, 0, maxX);
  cursorY = clamp(cursorY, 0, maxY);
  cursorOverlayEl.style.transform = `translate(${cursorX * zoom}px, ${cursorY * zoom}px)`;
}

function updateCursorOverlayAppearance(){
  if (!cursorOverlayEl) return;
  const border = eraserMode ? '#f88' : '#0ff';
  const fill = eraserMode ? 'rgba(255,136,136,0.15)' : 'rgba(0,255,255,0.12)';
  cursorOverlayEl.style.borderColor = border;
  cursorOverlayEl.style.background = fill;
}

function getSnappedCoords(x, y){
  const size = Math.max(1, penSize);
  const snapX = Math.floor(x / size) * size;
  const snapY = Math.floor(y / size) * size;
  const maxX = Math.max(0, canvas.width - size);
  const maxY = Math.max(0, canvas.height - size);
  return {
    x: clamp(snapX, 0, maxX),
    y: clamp(snapY, 0, maxY)
  };
}

function setCursorPositionFromCoords(x, y){
  if (!canvas.width || !canvas.height) return;
  const snapped = getSnappedCoords(x, y);
  cursorX = snapped.x;
  cursorY = snapped.y;
  updateCursorOverlayPosition();
}

function applyZoom(){
  const displayWidth = canvas.width * zoom;
  const displayHeight = canvas.height * zoom;
  canvas.style.width = displayWidth + 'px';
  canvas.style.height = displayHeight + 'px';
  canvasContainer.style.width = displayWidth + 'px';
  canvasContainer.style.height = displayHeight + 'px';

  if (gridOverlayEl) {
    gridOverlayEl.style.width = displayWidth + 'px';
    gridOverlayEl.style.height = displayHeight + 'px';
    gridOverlayEl.style.opacity = zoom > 1 ? '1' : '0.3';
  }

  updateOverlaySizing();
}

function updateOverlaySizing(){
  if (gridOverlayEl) {
    const size = Math.max(1, penSize) * zoom;
    const value = `${size}px ${size}px`;
    gridOverlayEl.style.backgroundSize = `${value}, ${value}`;
    gridOverlayEl.style.backgroundPosition = '0px 0px, 0px 0px';
  }
  if (cursorOverlayEl) {
    const cursorSize = Math.max(1, penSize) * zoom;
    cursorOverlayEl.style.width = cursorSize + 'px';
    cursorOverlayEl.style.height = cursorSize + 'px';
  }
  updateCursorOverlayPosition();
  updateCursorOverlayAppearance();
}

function setZoomLevel(value){
  const parsed = parseInt(value, 10);
  zoom = clamp(isNaN(parsed) ? zoom : parsed, 1, 32);
  zoomInput.value = zoom;
  applyZoom();
}

function updateCanvasSize(){
  let v = parseInt(pixelSizeInput.value,10);
  if (isNaN(v)) v = baseSize;
  v = clamp(v,1,maxSize);
  baseSize = v;
  pixelSizeInput.value = v;

  const [aw,ah] = aspectSelect.value.split(':').map(Number);
  if (aw >= ah) {
    gridW = clamp(v,1,maxSize);
    gridH = clamp(Math.round(v * ah / aw),1,maxSize);
  } else {
    gridH = clamp(v,1,maxSize);
    gridW = clamp(Math.round(v * aw / ah),1,maxSize);
  }

  canvas.width = gridW;
  canvas.height = gridH;
  ctx.imageSmoothingEnabled = false;
  updateCursorOverlayPosition();
  applyZoom();
}

pixelSizeInput.addEventListener('change', updateCanvasSize);
aspectSelect.addEventListener('change', updateCanvasSize);
zoomInput.addEventListener('change', e => setZoomLevel(e.target.value));
zoomInput.addEventListener('input', e => setZoomLevel(e.target.value));

function updateCanvasBackground(){
  if (!bgColorInput) return;
  if (transparentToggle.checked) {
    canvas.style.backgroundColor = 'transparent';
  } else {
    canvas.style.backgroundColor = bgColorInput.value;
  }
}

transparentToggle.addEventListener('change', updateCanvasBackground);

if (bgColorInput) {
  bgColorInput.addEventListener('input', e => applyColorToTarget('bg', e.target.value));
}

if (penColorInput) {
  penColorInput.addEventListener('input', e => applyColorToTarget('pen', e.target.value));
}

function applyColorToTarget(targetKey, color) {
  const normalized = normalizeHex(color);

  if (targetKey === 'bg') {
    if (bgColorInput) {
      bgColorInput.value = normalized;
    }
    updateCanvasBackground();
  } else if (targetKey === 'pen') {
    if (penColorInput) {
      penColorInput.value = normalized;
    }
    penColor = normalized;
  }
}

function setPenSize(value){
  let v = parseInt(value,10);
  if (isNaN(v) || v < 1) v = 1;
  penSize = v;
  penSizeInput.value = v;
  const snapped = getSnappedCoords(cursorX, cursorY);
  cursorX = snapped.x;
  cursorY = snapped.y;
  updateOverlaySizing();
}

penSizeInput.addEventListener('change', e => {
  setPenSize(e.target.value);
});
penSizeInput.addEventListener('input', e => {
  setPenSize(e.target.value);
});

function saveState(){
  historyStack.push(canvas.toDataURL());
  if (historyStack.length > 50) historyStack.shift();
}

function renderImageToCanvas(img){
  if (!img) return;
  saveState();
  clearCanvasContents();

  const tmp = document.createElement('canvas');
  tmp.width = canvas.width;
  tmp.height = canvas.height;
  const tctx = tmp.getContext('2d');
  tctx.imageSmoothingEnabled = false;

  if (!transparentToggle.checked) {
    tctx.fillStyle = bgColorInput.value;
    tctx.fillRect(0, 0, tmp.width, tmp.height);
  } else {
    tctx.clearRect(0, 0, tmp.width, tmp.height);
  }

  const imgRatio = img.width / img.height;
  const canvasRatio = canvas.width / canvas.height;
  let drawWidth, drawHeight;
  if (imgRatio > canvasRatio) {
    drawWidth = canvas.width;
    drawHeight = Math.max(1, Math.round(canvas.width / imgRatio));
  } else {
    drawHeight = canvas.height;
    drawWidth = Math.max(1, Math.round(canvas.height * imgRatio));
  }

  const dx = Math.round((canvas.width - drawWidth) / 2);
  const dy = Math.round((canvas.height - drawHeight) / 2);
  tctx.drawImage(img, dx, dy, drawWidth, drawHeight);

  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(tmp, 0, 0);
}

function quantizeChannel(v){
  const step = 85; // 4 levels (0, 85, 170, 255)
  return Math.max(0, Math.min(255, Math.round(v / step) * step));
}

function eightBitifyCanvas(){
  saveState();
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    data[i] = quantizeChannel(data[i]);
    data[i + 1] = quantizeChannel(data[i + 1]);
    data[i + 2] = quantizeChannel(data[i + 2]);
  }
  ctx.putImageData(imageData, 0, 0);
}

function canvasCoords(e){
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width / rect.width);
  const y = (e.clientY - rect.top) * (canvas.height / rect.height);
  return {x,y};
}

function paintAtCoords(x, y){
  const {x: sx, y: sy} = getSnappedCoords(x, y);
  const drawWidth = Math.min(penSize, canvas.width - sx);
  const drawHeight = Math.min(penSize, canvas.height - sy);
  if (drawWidth <= 0 || drawHeight <= 0) return;
  if (eraserMode) {
    eraseRectArea(sx, sy, drawWidth, drawHeight);
    return;
  }
  ctx.fillStyle = penColor;
  ctx.fillRect(sx, sy, drawWidth, drawHeight);
}

function eraseRectArea(x, y, width, height){
  if (transparentToggle.checked) {
    ctx.clearRect(x, y, width, height);
  } else {
    ctx.fillStyle = bgColorInput.value;
    ctx.fillRect(x, y, width, height);
  }
}

function drawShape(start, end, mode, shouldFill){
  if (!start || !end) return;
  const size = Math.max(1, penSize);

  const samePoint = start.x === end.x && start.y === end.y;
  if (samePoint) {
    if (eraserMode) {
      eraseRectArea(start.x, start.y, size, size);
    } else {
      ctx.fillStyle = penColor;
      ctx.fillRect(start.x, start.y, size, size);
    }
    return;
  }

  const bounds = {
    left: Math.min(start.x, end.x),
    top: Math.min(start.y, end.y),
    width: Math.max(Math.abs(end.x - start.x), 0) + size,
    height: Math.max(Math.abs(end.y - start.y), 0) + size
  };

  const path = new Path2D();
  switch (mode) {
    case 'circle': {
      const radiusX = Math.max(size / 2, bounds.width / 2);
      const radiusY = Math.max(size / 2, bounds.height / 2);
      const centerX = bounds.left + radiusX;
      const centerY = bounds.top + radiusY;
      path.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
      break;
    }
    case 'triangle': {
      const apexX = bounds.left + bounds.width / 2;
      path.moveTo(apexX, bounds.top);
      path.lineTo(bounds.left, bounds.top + bounds.height);
      path.lineTo(bounds.left + bounds.width, bounds.top + bounds.height);
      path.closePath();
      break;
    }
    case 'rectangle':
    default:
      path.rect(bounds.left, bounds.top, bounds.width, bounds.height);
      break;
  }

  ctx.save();
  ctx.lineWidth = size;
  ctx.lineJoin = 'miter';
  ctx.lineCap = 'butt';

  const xEnd = bounds.left + bounds.width;
  const yEnd = bounds.top + bounds.height;

  for (let y = bounds.top; y < yEnd; y += size) {
    for (let x = bounds.left; x < xEnd; x += size) {
      const centerX = x + size / 2;
      const centerY = y + size / 2;
      const matchesShape = shouldFill
        ? ctx.isPointInPath(path, centerX, centerY)
        : ctx.isPointInStroke(path, centerX, centerY);
      if (!matchesShape) continue;
      if (eraserMode) {
        eraseRectArea(x, y, size, size);
      } else {
        ctx.fillStyle = penColor;
        ctx.fillRect(x, y, size, size);
      }
    }
  }

  ctx.restore();
}

function finalizeShape(e){
  if (!drawing || drawingMode === 'pen') {
    drawing = false;
    return;
  }

  let snapped = shapeCurrent;
  if (e && typeof e.clientX === 'number' && typeof e.clientY === 'number') {
    const {x, y} = canvasCoords(e);
    snapped = getSnappedCoords(x, y);
  }

  if (!snapped && shapeStart) {
    snapped = shapeStart;
  }

  if (shapeSnapshot && shapeStart) {
    ctx.putImageData(shapeSnapshot, 0, 0);
    drawShape(shapeStart, snapped || shapeStart, drawingMode, fillShapes);
  }

  drawing = false;
  shapeStart = null;
  shapeCurrent = null;
  shapeSnapshot = null;
}

function setPickColorMode(active){
  pickColorMode = active;
  if (colorPickerToolBtn) {
    colorPickerToolBtn.classList.toggle('active', active);
  }
  canvas.style.cursor = active ? 'copy' : 'crosshair';
}

function sampleCanvasColor(e){
  if (canvas.width === 0 || canvas.height === 0) {
    setPickColorMode(false);
    return;
  }
  const {x,y} = canvasCoords(e);
  const ix = clamp(Math.floor(x), 0, canvas.width - 1);
  const iy = clamp(Math.floor(y), 0, canvas.height - 1);
  const data = ctx.getImageData(ix, iy, 1, 1).data;
  let hex;
  if (data[3] === 0) {
    hex = transparentToggle.checked ? penColor : bgColorInput.value;
  } else {
    hex = RGBtoHex(data[0], data[1], data[2]);
  }
  applyColorToTarget('pen', hex);
  setPickColorMode(false);
}

canvas.addEventListener('mousedown', e => {
  if (pickColorMode) {
    sampleCanvasColor(e);
    return;
  }

  if (!canvas.width || !canvas.height) return;

  const {x, y} = canvasCoords(e);
  setCursorPositionFromCoords(x, y);

  const snappedStart = getSnappedCoords(x, y);
  const usingShapeTool = drawingMode !== 'pen';
  drawing = true;
  saveState();          // stroke-level undo

  if (usingShapeTool) {
    shapeStart = snappedStart;
    shapeCurrent = snappedStart;
    shapeSnapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);
  } else {
    paintAtCoords(cursorX, cursorY);
  }
});
canvas.addEventListener('mousemove', e => {
  const {x,y} = canvasCoords(e);
  setCursorPositionFromCoords(x,y);
  if (!drawing) return;
  if (drawingMode === 'pen') {
    paintAtCoords(cursorX, cursorY);
  } else if (shapeSnapshot && shapeStart) {
    shapeCurrent = getSnappedCoords(x, y);
    ctx.putImageData(shapeSnapshot, 0, 0);
    drawShape(shapeStart, shapeCurrent, drawingMode, fillShapes);
  }
});
canvas.addEventListener('mouseup', e => finalizeShape(e));
canvas.addEventListener('mouseleave', e => finalizeShape(e));
window.addEventListener('mouseup', e => finalizeShape(e));

function toggleCursorPixel(){
  if (!canvas.width || !canvas.height) return;
  const blockWidth = Math.min(penSize, canvas.width - cursorX);
  const blockHeight = Math.min(penSize, canvas.height - cursorY);
  if (blockWidth <= 0 || blockHeight <= 0) return;

  const blockData = ctx.getImageData(cursorX, cursorY, blockWidth, blockHeight).data;
  let isEmpty = true;
  const bgRGB = transparentToggle.checked ? null : hexToRGB(bgColorInput.value);
  for (let i = 0; i < blockData.length; i += 4) {
    if (transparentToggle.checked) {
      if (blockData[i + 3] !== 0) {
        isEmpty = false;
        break;
      }
    } else {
      const matchesBg = blockData[i] === bgRGB.r && blockData[i + 1] === bgRGB.g && blockData[i + 2] === bgRGB.b && blockData[i + 3] === 255;
      if (!matchesBg) {
        isEmpty = false;
        break;
      }
    }
  }

  saveState();
  if (isEmpty) {
    ctx.fillStyle = penColor;
    ctx.fillRect(cursorX, cursorY, blockWidth, blockHeight);
  } else {
    if (transparentToggle.checked) {
      ctx.clearRect(cursorX, cursorY, blockWidth, blockHeight);
    } else {
      ctx.fillStyle = bgColorInput.value;
      ctx.fillRect(cursorX, cursorY, blockWidth, blockHeight);
    }
  }
}

function activeElementConsumesKeys(){
  const active = document.activeElement;
  if (!active) return false;
  if (active === document.body) return false;
  const tag = active.tagName;
  return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || tag === 'BUTTON' || active.isContentEditable;
}

window.addEventListener('keydown', e => {
  if (activeElementConsumesKeys()) return;
  if (e.repeat && (e.key === ' ' || e.key === 'Spacebar')) return;
  let handled = false;
  switch (e.key) {
    case 'ArrowUp':
      cursorY = clamp(cursorY - penSize, 0, Math.max(0, canvas.height - penSize));
      handled = true;
      break;
    case 'ArrowDown':
      cursorY = clamp(cursorY + penSize, 0, Math.max(0, canvas.height - penSize));
      handled = true;
      break;
    case 'ArrowLeft':
      cursorX = clamp(cursorX - penSize, 0, Math.max(0, canvas.width - penSize));
      handled = true;
      break;
    case 'ArrowRight':
      cursorX = clamp(cursorX + penSize, 0, Math.max(0, canvas.width - penSize));
      handled = true;
      break;
    case ' ': // Space
    case 'Spacebar':
      toggleCursorPixel();
      handled = true;
      break;
    default:
      break;
  }

  if (handled) {
    e.preventDefault();
    updateCursorOverlayPosition();
  }
});

// Undo / Reset / Export
const undoBtn = document.getElementById('undoBtn');
const resetBtn = document.getElementById('resetBtn');
const exportBtn = document.getElementById('exportBtn');

undoBtn.addEventListener('click', () => {
  if (!historyStack.length) return;
  const data = historyStack.pop();
  const img = new Image();
  img.onload = () => {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img,0,0);
  };
  img.src = data;
});

resetBtn.addEventListener('click', () => {
  const msg = "Hold up pixel wizard, this will vaporize your masterpiece into the digital void and give you a fresh, empty canvas. Proceed?";
  if (!confirm(msg)) return;

  // Hard clear: wipe pixels and history so nothing can be undone back
  clearCanvasContents();
  historyStack = [];
  uploadedImage = null;
});

exportBtn.addEventListener('click', () => {
  const exp = document.createElement('canvas');
  exp.width = canvas.width;
  exp.height = canvas.height;
  const ectx = exp.getContext('2d');
  if (!transparentToggle.checked) {
    ectx.fillStyle = bgColorInput.value;
    ectx.fillRect(0,0,exp.width,exp.height);
  }
  ectx.drawImage(canvas,0,0);
  const link = document.createElement('a');
  let name = fileNameInput.value.trim() || 'design';
  if (!name.toLowerCase().endsWith('.png')) name += '.png';
  link.download = name;
  link.href = exp.toDataURL('image/png');
  link.click();
});

uploadBtn.addEventListener('click', () => uploadInput.click());

uploadInput.addEventListener('change', e => {
  const file = e.target.files && e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = ev => {
    const img = new Image();
    img.onload = () => {
      uploadedImage = img;
      renderImageToCanvas(img);
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
  uploadInput.value = '';
});

bitifyBtn.addEventListener('click', () => {
  if (canvas.width === 0 || canvas.height === 0) return;
  eightBitifyCanvas();
});

if (colorPickerToolBtn) {
  colorPickerToolBtn.addEventListener('click', () => {
    setPickColorMode(!pickColorMode);
  });
}

window.addEventListener('keydown', e => {
  if (e.key === 'Escape' && pickColorMode) {
    setPickColorMode(false);
  }
});

function hexToRGB(hex){
  hex = hex.replace('#','');
  if (hex.length !== 6) return {r:255,g:255,b:255};
  return {
    r: parseInt(hex.slice(0,2),16),
    g: parseInt(hex.slice(2,4),16),
    b: parseInt(hex.slice(4,6),16)
  };
}

function RGBtoHex(r,g,b){
  return '#' + [r,g,b].map(v=>{
    const n = clamp(v,0,255)|0;
    return n.toString(16).padStart(2,'0');
  }).join('');
}

// ============
// Initialization
// ============
setPenSize(penSizeInput.value);
updateCanvasSize();
updateCanvasBackground();

// load default image placeholder centered (optional; here we just clear)
clearCanvasContents();

</script>
</body>
</html>
