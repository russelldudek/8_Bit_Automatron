<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>8-Bit Automatron</title>
<style>
  body {
    font-family: monospace;
    background:#222;
    color:#eee;
    margin:0;
    padding:0;
    height:100vh;
    width:100vw;
    display:flex;
    flex-direction:column;
  }
  #toolbar-top, #toolbar-bottom {
    padding:10px;
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    justify-content:center;
    align-items:center;
    background:#111;
    z-index:2;
  }
  #toolbar-bottom { padding-top:0; flex-direction:column; }

  .toolbar-row {
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    justify-content:center;
    width:100%;
  }

  canvas {
    image-rendering: pixelated;
    background:transparent;
    cursor:crosshair;
  }

  .control {
    background:#333;
    padding:6px 10px;
    border-radius:4px;
    color:#fff;
    border:1px solid #555;
    display:flex;
    align-items:center;
    justify-content:center;
    min-height:36px;
    height:36px;
    min-width:160px;
    box-sizing:border-box;
    font-size:0.9rem;
  }
  .control input,
  .control select {
    font-family:inherit;
    font-size:0.9rem;
    margin-left:6px;
    height:24px;
  }

  .button-control {
    cursor:pointer;
    background:#333;
    border:1px solid #555;
    border-radius:4px;
    padding:6px 10px;
    color:#fff;
    min-height:36px;
    min-width:160px;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .button-control:hover { background:#444; }
  .button-control:active { background:#0a0; border-color:#0f0; }

  .swatch {
    width:36px;
    height:24px;
    border:1px solid #444;
    cursor:pointer;
  }

  #canvasWrapper {
    flex:1;
    display:flex;
    justify-content:center;
    align-items:center;
    padding:20px;
    box-sizing:border-box;
  }

  #canvasContainer {
    position:relative;
    display:inline-block;
    border:2px solid #666;
  }

  #canvasContainer canvas {
    display:block;
  }

  #gridOverlay,
  #cursorOverlay {
    position:absolute;
    top:0;
    left:0;
    pointer-events:none;
  }

  #gridOverlay {
    background-image:
      linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
      linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
    background-repeat:repeat;
    box-sizing:border-box;
    z-index:1;
  }

  #cursorOverlay {
    border:2px solid #0ff;
    box-sizing:border-box;
    z-index:2;
    background:rgba(0,255,255,0.12);
  }

  /* Color picker */
  #customColorPicker {
    position:fixed;
    background:#333;
    padding:12px;
    border:1px solid #666;
    border-radius:6px;
    display:none;
    z-index:10;
  }
  #svSquare { width:200px; height:200px; cursor:pointer; }
  #hueSlider { width:20px; height:200px; cursor:pointer; margin-left:10px; }
  #opacitySlider { width:200px; margin-top:8px; }
  #svCursor {
    position:absolute;
    width:10px;
    height:10px;
    border:2px solid #fff;
    border-radius:50%;
    pointer-events:none;
    transform:translate(-5px,-5px);
  }
  #hueCursor {
    position:absolute;
    width:26px;
    height:4px;
    background:#fff;
    pointer-events:none;
    transform:translateX(-3px);
  }
  #pickerButtons { display:flex; gap:10px; margin-top:10px; }
  #historyRow { display:flex; gap:6px; margin-top:8px; }
  .historySwatch {
    width:24px;
    height:24px;
    border:1px solid #666;
    cursor:pointer;
  }
</style>
</head>
<body>
<h2 style="margin:8px 0; text-align:center; width:100%;">8-Bit Automatron</h2>

<div id="toolbar-top">
  <div class="control">Pixel Size: <input type="number" id="pixelSize" value="200" min="1" max="1024" style="width:4em;"></div>
  <div class="control">Aspect Ratio:
    <select id="aspect">
      <option value="1:1">1:1</option>
      <option value="4:3">4:3</option>
      <option value="3:4">3:4</option>
      <option value="16:9">16:9</option>
      <option value="4:1">Banner</option>
    </select>
  </div>
  <div class="control">Zoom: <input type="number" id="zoomLevel" value="4" min="1" max="32" style="width:4em;"></div>
  <div class="control">Background:
    <div id="bgSwatch" class="swatch" style="background:#000000; margin-left:6px;"></div>
    <input type="hidden" id="bgColorInput" value="#000000">
    <label style="margin-left:8px;"><input type="checkbox" id="transparentBg" checked> Transparent</label>
  </div>
  <div class="control">Pen Size: <input id="penSize" type="number" value="4" min="1" max="20" style="width:4em;"></div>
  <div class="control">Pen Color:
    <div id="penSwatch" class="swatch" style="background:#ffffff; margin-left:6px;"></div>
    <input type="hidden" id="penColorInput" value="#ffffff">
  </div>
</div>

<div id="toolbar-bottom">
  <div class="toolbar-row">
    <button id="undoBtn" class="button-control">Undo</button>
    <button id="resetBtn" class="button-control">Reset</button>
  </div>
  <div class="toolbar-row">
    <button id="uploadBtn" class="button-control">Upload PNG</button>
    <input type="file" id="uploadInput" accept="image/png" style="display:none;">
    <button id="bitifyBtn" class="button-control">8-Bitify</button>
    <button id="exportBtn" class="button-control">Export PNG</button>
  </div>
</div>

<div id="canvasWrapper">
  <div id="canvasContainer">
    <canvas id="canvas"></canvas>
    <div id="gridOverlay"></div>
    <div id="cursorOverlay"></div>
  </div>
</div>

<!-- HSV Color Picker anchored under swatch -->
<div id="customColorPicker">
  <div style="display:flex; position:relative;">
    <div style="position:relative;">
      <canvas id="svSquare"></canvas>
      <div id="svCursor"></div>
    </div>
    <div style="position:relative; margin-left:10px;">
      <canvas id="hueSlider"></canvas>
      <div id="hueCursor"></div>
    </div>
  </div>

  <input type="range" id="opacitySlider" min="0" max="1" step="0.01" value="1">

  <div style="margin-top:6px;">Hex: <input id="customHex" type="text" style="width:90px;"></div>
  <div style="margin-top:6px;">
    R:<input id="rInput" type="number" min="0" max="255" style="width:4em;">
    G:<input id="gInput" type="number" min="0" max="255" style="width:4em;">
    B:<input id="bInput" type="number" min="0" max="255" style="width:4em;">
  </div>

  <div id="historyRow"></div>

  <div id="pickerButtons">
    <button id="applyColor" class="button-control" style="min-width:100px;">Apply</button>
    <button id="cancelColor" class="button-control" style="min-width:100px;">Cancel</button>
  </div>
</div>

<script>
// =====================
// Canvas + Drawing Core
// =====================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

const pixelSizeInput = document.getElementById('pixelSize');
const aspectSelect = document.getElementById('aspect');
const bgSwatch = document.getElementById('bgSwatch');
const bgColorInput = document.getElementById('bgColorInput');
const transparentToggle = document.getElementById('transparentBg');
const penSizeInput = document.getElementById('penSize');
const penSwatch = document.getElementById('penSwatch');
const penColorInput = document.getElementById('penColorInput');
const uploadBtn = document.getElementById('uploadBtn');
const uploadInput = document.getElementById('uploadInput');
const bitifyBtn = document.getElementById('bitifyBtn');
const zoomInput = document.getElementById('zoomLevel');
const canvasContainer = document.getElementById('canvasContainer');
const gridOverlayEl = document.getElementById('gridOverlay');
const cursorOverlayEl = document.getElementById('cursorOverlay');

let baseSize = 200;
const maxSize = 1024;
let gridW = baseSize;
let gridH = baseSize;

let drawing = false;
let penSize = 4;
let penColor = '#ffffff';
let historyStack = [];
let uploadedImage = null;
let zoom = clamp(parseInt(zoomInput.value, 10) || 1, 1, 32);
zoomInput.value = zoom;
let cursorX = 0;
let cursorY = 0;

function clamp(val,min,max){return Math.max(min,Math.min(max,val));}

function clearCanvasContents(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (!transparentToggle.checked) {
    ctx.fillStyle = bgColorInput.value;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
}

function updateCursorOverlayPosition(){
  if (!cursorOverlayEl) return;
  const maxX = Math.max(0, canvas.width - 1);
  const maxY = Math.max(0, canvas.height - 1);
  cursorX = clamp(cursorX, 0, maxX);
  cursorY = clamp(cursorY, 0, maxY);
  cursorOverlayEl.style.transform = `translate(${cursorX * zoom}px, ${cursorY * zoom}px)`;
}

function setCursorPositionFromCoords(x, y){
  if (!canvas.width || !canvas.height) return;
  cursorX = clamp(Math.floor(x), 0, Math.max(0, canvas.width - 1));
  cursorY = clamp(Math.floor(y), 0, Math.max(0, canvas.height - 1));
  updateCursorOverlayPosition();
}

function applyZoom(){
  const displayWidth = canvas.width * zoom;
  const displayHeight = canvas.height * zoom;
  canvas.style.width = displayWidth + 'px';
  canvas.style.height = displayHeight + 'px';
  canvasContainer.style.width = displayWidth + 'px';
  canvasContainer.style.height = displayHeight + 'px';

  if (gridOverlayEl) {
    gridOverlayEl.style.width = displayWidth + 'px';
    gridOverlayEl.style.height = displayHeight + 'px';
    gridOverlayEl.style.backgroundSize = `${zoom}px ${zoom}px`;
    gridOverlayEl.style.opacity = zoom > 1 ? '1' : '0.3';
  }

  if (cursorOverlayEl) {
    cursorOverlayEl.style.width = zoom + 'px';
    cursorOverlayEl.style.height = zoom + 'px';
  }

  updateCursorOverlayPosition();
}

function setZoomLevel(value){
  const parsed = parseInt(value, 10);
  zoom = clamp(isNaN(parsed) ? zoom : parsed, 1, 32);
  zoomInput.value = zoom;
  applyZoom();
}

function updateCanvasSize(){
  let v = parseInt(pixelSizeInput.value,10);
  if (isNaN(v)) v = baseSize;
  v = clamp(v,1,maxSize);
  baseSize = v;
  pixelSizeInput.value = v;

  const [aw,ah] = aspectSelect.value.split(':').map(Number);
  if (aw >= ah) {
    gridW = clamp(v,1,maxSize);
    gridH = clamp(Math.round(v * ah / aw),1,maxSize);
  } else {
    gridH = clamp(v,1,maxSize);
    gridW = clamp(Math.round(v * aw / ah),1,maxSize);
  }

  canvas.width = gridW;
  canvas.height = gridH;
  ctx.imageSmoothingEnabled = false;
  updateCursorOverlayPosition();
  applyZoom();
}

pixelSizeInput.addEventListener('change', updateCanvasSize);
aspectSelect.addEventListener('change', updateCanvasSize);
zoomInput.addEventListener('change', e => setZoomLevel(e.target.value));
zoomInput.addEventListener('input', e => setZoomLevel(e.target.value));

function updateCanvasBackground(){
  if (transparentToggle.checked) {
    canvas.style.backgroundColor = 'transparent';
  } else {
    canvas.style.backgroundColor = bgColorInput.value;
  }
}

transparentToggle.addEventListener('change', updateCanvasBackground);

penSizeInput.addEventListener('change', e => {
  let v = parseInt(e.target.value,10);
  if (isNaN(v) || v < 1) v = 1;
  penSize = v;
  penSizeInput.value = v;
});

function saveState(){
  historyStack.push(canvas.toDataURL());
  if (historyStack.length > 50) historyStack.shift();
}

function renderImageToCanvas(img){
  if (!img) return;
  saveState();
  clearCanvasContents();

  const tmp = document.createElement('canvas');
  tmp.width = canvas.width;
  tmp.height = canvas.height;
  const tctx = tmp.getContext('2d');
  tctx.imageSmoothingEnabled = false;

  if (!transparentToggle.checked) {
    tctx.fillStyle = bgColorInput.value;
    tctx.fillRect(0, 0, tmp.width, tmp.height);
  } else {
    tctx.clearRect(0, 0, tmp.width, tmp.height);
  }

  const imgRatio = img.width / img.height;
  const canvasRatio = canvas.width / canvas.height;
  let drawWidth, drawHeight;
  if (imgRatio > canvasRatio) {
    drawWidth = canvas.width;
    drawHeight = Math.max(1, Math.round(canvas.width / imgRatio));
  } else {
    drawHeight = canvas.height;
    drawWidth = Math.max(1, Math.round(canvas.height * imgRatio));
  }

  const dx = Math.round((canvas.width - drawWidth) / 2);
  const dy = Math.round((canvas.height - drawHeight) / 2);
  tctx.drawImage(img, dx, dy, drawWidth, drawHeight);

  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(tmp, 0, 0);
}

function quantizeChannel(v){
  const step = 85; // 4 levels (0, 85, 170, 255)
  return Math.max(0, Math.min(255, Math.round(v / step) * step));
}

function eightBitifyCanvas(){
  saveState();
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    data[i] = quantizeChannel(data[i]);
    data[i + 1] = quantizeChannel(data[i + 1]);
    data[i + 2] = quantizeChannel(data[i + 2]);
  }
  ctx.putImageData(imageData, 0, 0);
}

function canvasCoords(e){
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width / rect.width);
  const y = (e.clientY - rect.top) * (canvas.height / rect.height);
  return {x,y};
}

function paintAtCoords(x, y){
  ctx.fillStyle = penColor;
  const ix = Math.floor(x);
  const iy = Math.floor(y);
  for (let dx = -penSize; dx <= penSize; dx++){
    for (let dy = -penSize; dy <= penSize; dy++){
      ctx.fillRect(ix + dx, iy + dy, 1, 1);
    }
  }
}

function paintFromEvent(e){
  const {x,y} = canvasCoords(e);
  setCursorPositionFromCoords(x,y);
  paintAtCoords(x,y);
}

canvas.addEventListener('mousedown', e => {
  drawing = true;
  saveState();          // stroke-level undo
  paintFromEvent(e);
});
canvas.addEventListener('mousemove', e => {
  const {x,y} = canvasCoords(e);
  setCursorPositionFromCoords(x,y);
  if (drawing) paintAtCoords(x,y);
});
canvas.addEventListener('mouseup', () => drawing=false);
canvas.addEventListener('mouseleave', () => drawing=false);

function toggleCursorPixel(){
  if (!canvas.width || !canvas.height) return;
  const pixel = ctx.getImageData(cursorX, cursorY, 1, 1).data;
  let isEmpty;
  if (transparentToggle.checked) {
    isEmpty = pixel[3] === 0;
  } else {
    const bgRGB = hexToRGB(bgColorInput.value);
    isEmpty = pixel[3] === 0 || (pixel[0] === bgRGB.r && pixel[1] === bgRGB.g && pixel[2] === bgRGB.b && pixel[3] === 255);
  }

  saveState();
  if (isEmpty) {
    ctx.fillStyle = penColor;
    ctx.fillRect(cursorX, cursorY, 1, 1);
  } else {
    if (transparentToggle.checked) {
      ctx.clearRect(cursorX, cursorY, 1, 1);
    } else {
      ctx.fillStyle = bgColorInput.value;
      ctx.fillRect(cursorX, cursorY, 1, 1);
    }
  }
}

function activeElementConsumesKeys(){
  const active = document.activeElement;
  if (!active) return false;
  if (active === document.body) return false;
  const tag = active.tagName;
  return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || tag === 'BUTTON' || active.isContentEditable;
}

window.addEventListener('keydown', e => {
  if (activeElementConsumesKeys()) return;
  if (e.repeat && (e.key === ' ' || e.key === 'Spacebar')) return;
  let handled = false;
  switch (e.key) {
    case 'ArrowUp':
      cursorY = clamp(cursorY - 1, 0, Math.max(0, canvas.height - 1));
      handled = true;
      break;
    case 'ArrowDown':
      cursorY = clamp(cursorY + 1, 0, Math.max(0, canvas.height - 1));
      handled = true;
      break;
    case 'ArrowLeft':
      cursorX = clamp(cursorX - 1, 0, Math.max(0, canvas.width - 1));
      handled = true;
      break;
    case 'ArrowRight':
      cursorX = clamp(cursorX + 1, 0, Math.max(0, canvas.width - 1));
      handled = true;
      break;
    case ' ': // Space
    case 'Spacebar':
      toggleCursorPixel();
      handled = true;
      break;
    default:
      break;
  }

  if (handled) {
    e.preventDefault();
    updateCursorOverlayPosition();
  }
});

// Undo / Reset / Export
const undoBtn = document.getElementById('undoBtn');
const resetBtn = document.getElementById('resetBtn');
const exportBtn = document.getElementById('exportBtn');

undoBtn.addEventListener('click', () => {
  if (!historyStack.length) return;
  const data = historyStack.pop();
  const img = new Image();
  img.onload = () => {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img,0,0);
  };
  img.src = data;
});

resetBtn.addEventListener('click', () => {
  const msg = "Hold up pixel wizard, this will vaporize your masterpiece into the digital void and give you a fresh, empty canvas. Proceed?";
  if (!confirm(msg)) return;

  // Hard clear: wipe pixels and history so nothing can be undone back
  clearCanvasContents();
  historyStack = [];
  uploadedImage = null;
});

exportBtn.addEventListener('click', () => {
  const exp = document.createElement('canvas');
  exp.width = canvas.width;
  exp.height = canvas.height;
  const ectx = exp.getContext('2d');
  if (!transparentToggle.checked) {
    ectx.fillStyle = bgColorInput.value;
    ectx.fillRect(0,0,exp.width,exp.height);
  }
  ectx.drawImage(canvas,0,0);
  const link = document.createElement('a');
  link.download = 'design.png';
  link.href = exp.toDataURL('image/png');
  link.click();
});

uploadBtn.addEventListener('click', () => uploadInput.click());

uploadInput.addEventListener('change', e => {
  const file = e.target.files && e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = ev => {
    const img = new Image();
    img.onload = () => {
      uploadedImage = img;
      renderImageToCanvas(img);
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
  uploadInput.value = '';
});

bitifyBtn.addEventListener('click', () => {
  if (canvas.width === 0 || canvas.height === 0) return;
  eightBitifyCanvas();
});

// ==========================
// HSV Color Picker subsystem
// ==========================
const picker = document.getElementById('customColorPicker');
const sv = document.getElementById('svSquare');
const hue = document.getElementById('hueSlider');
const svCtx = sv.getContext('2d');
const hueCtx = hue.getContext('2d');
const svCursor = document.getElementById('svCursor');
const hueCursor = document.getElementById('hueCursor');
const opacitySlider = document.getElementById('opacitySlider');
const customHex = document.getElementById('customHex');
const rInput = document.getElementById('rInput');
const gInput = document.getElementById('gInput');
const bInput = document.getElementById('bInput');
const applyColor = document.getElementById('applyColor');
const cancelColor = document.getElementById('cancelColor');
const historyRow = document.getElementById('historyRow');

sv.width = 200; sv.height = 200;
hue.width = 20; hue.height = 200;

let hsv = {h:0, s:1, v:1};
let currentPickerTarget = null; // 'bg' or 'pen'
let historyColors = [];

function HSVtoRGB(h,s,v){
  let f = n => {
    let k = (n + h*6) % 6;
    return v - v*s*Math.max(Math.min(k,4-k,1),0);
  };
  return {
    r: Math.round(f(5)*255),
    g: Math.round(f(3)*255),
    b: Math.round(f(1)*255)
  };
}

function RGBtoHSV(r,g,b){
  r/=255; g/=255; b/=255;
  const max = Math.max(r,g,b), min = Math.min(r,g,b);
  const d = max-min;
  let h;
  const v = max;
  const s = max === 0 ? 0 : d/max;
  if (d === 0) h = 0;
  else if (max === r) h = ((g-b)/d + (g<b?6:0))/6;
  else if (max === g) h = ((b-r)/d + 2)/6;
  else h = ((r-g)/d + 4)/6;
  return {h,s,v};
}

function hexToRGB(hex){
  hex = hex.replace('#','');
  if (hex.length !== 6) return {r:255,g:255,b:255};
  return {
    r: parseInt(hex.slice(0,2),16),
    g: parseInt(hex.slice(2,4),16),
    b: parseInt(hex.slice(4,6),16)
  };
}

function RGBtoHex(r,g,b){
  return '#' + [r,g,b].map(v=>{
    const n = clamp(v,0,255)|0;
    return n.toString(16).padStart(2,'0');
  }).join('');
}

function drawHue(){
  const grad = hueCtx.createLinearGradient(0,0,0,hue.height);
  grad.addColorStop(0,'#f00');
  grad.addColorStop(0.17,'#ff0');
  grad.addColorStop(0.33,'#0f0');
  grad.addColorStop(0.5,'#0ff');
  grad.addColorStop(0.67,'#00f');
  grad.addColorStop(0.83,'#f0f');
  grad.addColorStop(1,'#f00');
  hueCtx.fillStyle = grad;
  hueCtx.fillRect(0,0,hue.width,hue.height);
}

function drawSV(){
  const rgb = HSVtoRGB(hsv.h,1,1);
  let gradX = svCtx.createLinearGradient(0,0,sv.width,0);
  gradX.addColorStop(0,'#ffffff');
  gradX.addColorStop(1,`rgb(${rgb.r},${rgb.g},${rgb.b})`);
  svCtx.fillStyle = gradX;
  svCtx.fillRect(0,0,sv.width,sv.height);

  let gradY = svCtx.createLinearGradient(0,0,0,sv.height);
  gradY.addColorStop(0,'rgba(0,0,0,0)');
  gradY.addColorStop(1,'#000000');
  svCtx.fillStyle = gradY;
  svCtx.fillRect(0,0,sv.width,sv.height);
}

function updatePickerFields(){
  const rgb = HSVtoRGB(hsv.h,hsv.s,hsv.v);
  customHex.value = RGBtoHex(rgb.r,rgb.g,rgb.b);
  rInput.value = rgb.r;
  gInput.value = rgb.g;
  bInput.value = rgb.b;

  // cursor positions
  const x = hsv.s * sv.width;
  const y = (1 - hsv.v) * sv.height;
  const svRect = sv.getBoundingClientRect();
  svCursor.style.left = (svRect.left + x) + 'px';
  svCursor.style.top  = (svRect.top + y) + 'px';

  const hy = hsv.h * hue.height;
  const hueRect = hue.getBoundingClientRect();
  hueCursor.style.left = (hueRect.left + hue.width/2) + 'px';
  hueCursor.style.top  = (hueRect.top + hy) + 'px';
}

function openPicker(targetKey, swatch){
  currentPickerTarget = targetKey; // 'bg' or 'pen'
  const rect = swatch.getBoundingClientRect();
  picker.style.left = rect.left + 'px';
  picker.style.top  = (rect.bottom + 4) + 'px';

  const hex = targetKey === 'bg' ? bgColorInput.value : penColorInput.value;
  const rgb = hexToRGB(hex);
  hsv = RGBtoHSV(rgb.r,rgb.g,rgb.b);
  drawHue();
  drawSV();
  updatePickerFields();
  picker.style.display = 'block';
}

function closePicker(){ picker.style.display = 'none'; }

function setHSVFromSVEvent(e){
  const rect = sv.getBoundingClientRect();
  let x = clamp((e.clientX - rect.left) / rect.width, 0, 1);
  let y = clamp((e.clientY - rect.top) / rect.height, 0, 1);
  hsv.s = x;
  hsv.v = 1 - y;
  drawSV();
  updatePickerFields();
}

function setHSVFromHueEvent(e){
  const rect = hue.getBoundingClientRect();
  let y = clamp((e.clientY - rect.top) / rect.height, 0, 1);
  hsv.h = y;
  drawHue();
  drawSV();
  updatePickerFields();
}

sv.addEventListener('mousedown', e => {
  setHSVFromSVEvent(e);
  function move(ev){ setHSVFromSVEvent(ev); }
  function up(){ window.removeEventListener('mousemove',move); window.removeEventListener('mouseup',up); }
  window.addEventListener('mousemove',move);
  window.addEventListener('mouseup',up);
});

hue.addEventListener('mousedown', e => {
  setHSVFromHueEvent(e);
  function move(ev){ setHSVFromHueEvent(ev); }
  function up(){ window.removeEventListener('mousemove',move); window.removeEventListener('mouseup',up); }
  window.addEventListener('mousemove',move);
  window.addEventListener('mouseup',up);
});

// Hex and RGB field sync
customHex.addEventListener('input', () => {
  let v = customHex.value.trim();
  if (!v.startsWith('#')) v = '#' + v;
  if (/^#([0-9A-Fa-f]{6})$/.test(v)){
    const rgb = hexToRGB(v);
    hsv = RGBtoHSV(rgb.r,rgb.g,rgb.b);
    drawHue();
    drawSV();
    updatePickerFields();
  }
});

[rInput,gInput,bInput].forEach(inp => {
  inp.addEventListener('change', () => {
    const r = parseInt(rInput.value,10)||0;
    const g = parseInt(gInput.value,10)||0;
    const b = parseInt(bInput.value,10)||0;
    hsv = RGBtoHSV(r,g,b);
    drawHue();
    drawSV();
    updatePickerFields();
  });
});

// History
function pushHistory(color){
  historyColors.unshift(color);
  if (historyColors.length > 8) historyColors.pop();
  historyRow.innerHTML = '';
  historyColors.forEach(col => {
    const d = document.createElement('div');
    d.className = 'historySwatch';
    d.style.backgroundColor = col;
    d.addEventListener('click', () => {
      const rgb = hexToRGB(col);
      hsv = RGBtoHSV(rgb.r,rgb.g,rgb.b);
      drawHue();
      drawSV();
      updatePickerFields();
    });
    historyRow.appendChild(d);
  });
}

applyColor.addEventListener('click', () => {
  const rgb = HSVtoRGB(hsv.h,hsv.s,hsv.v);
  const hex = RGBtoHex(rgb.r,rgb.g,rgb.b);
  pushHistory(hex);
  if (currentPickerTarget === 'bg'){
    bgColorInput.value = hex;
    bgSwatch.style.backgroundColor = hex;
    updateCanvasBackground();
  } else if (currentPickerTarget === 'pen'){
    penColorInput.value = hex;
    penSwatch.style.backgroundColor = hex;
    penColor = hex;
  }
  closePicker();
});

cancelColor.addEventListener('click', closePicker);

bgSwatch.addEventListener('click', () => openPicker('bg', bgSwatch));
penSwatch.addEventListener('click', () => openPicker('pen', penSwatch));

// ============
// Initialization
// ============
updateCanvasSize();
updateCanvasBackground();

// load default image placeholder centered (optional; here we just clear)
clearCanvasContents();

</script>
</body>
</html>
