<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>8-Bit Automatron</title>
<style>
  body {
    font-family: monospace;
    background:#222;
    color:#eee;
    margin:0;
    padding:0;
    height:100vh;
    width:100vw;
    display:flex;
    flex-direction:column;
  }
  #toolbar-top, #toolbar-bottom {
    padding:10px;
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    justify-content:center;
    align-items:center;
    background:#111;
    z-index:2;
  }
  #toolbar-bottom { padding-top:0; flex-direction:column; }

  .toolbar-row {
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    justify-content:center;
    width:100%;
  }

  canvas {
    image-rendering: pixelated;
    border:2px solid #666;
    background:transparent;
    cursor:crosshair;
  }

  .control {
    background:#333;
    padding:6px 10px;
    border-radius:4px;
    color:#fff;
    border:1px solid #555;
    display:flex;
    align-items:center;
    justify-content:center;
    min-height:36px;
    height:36px;
    min-width:160px;
    box-sizing:border-box;
    font-size:0.9rem;
  }
  .control input,
  .control select {
    font-family:inherit;
    font-size:0.9rem;
    margin-left:6px;
    height:24px;
  }

  .button-control {
    cursor:pointer;
    background:#333;
    border:1px solid #555;
    border-radius:4px;
    padding:6px 10px;
    color:#fff;
    min-height:36px;
    min-width:160px;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .button-control:hover { background:#444; }
  .button-control:active { background:#0a0; border-color:#0f0; }
  .button-control.active {
    background:#225;
    border-color:#4af;
  }

  .swatch {
    width:36px;
    height:24px;
    border:1px solid #444;
    cursor:pointer;
  }

  #zoomControls {
    display:flex;
    justify-content:center;
    align-items:center;
    gap:10px;
    margin-bottom:16px;
  }

  #zoomControls button {
    width:40px;
    height:32px;
    font-size:1.2rem;
    cursor:pointer;
    background:#333;
    border:1px solid #555;
    border-radius:4px;
    color:#fff;
  }

  #zoomDisplay {
    min-width:60px;
    text-align:center;
  }

  #canvasWrapper {
    flex:1;
    display:flex;
    justify-content:center;
    align-items:center;
    padding:20px;
    box-sizing:border-box;
    overflow:auto;
  }

  /* Color picker */
  #customColorPicker {
    position:fixed;
    background:#333;
    padding:12px;
    border:1px solid #666;
    border-radius:6px;
    display:none;
    z-index:10;
  }
  #svSquare { width:200px; height:200px; cursor:pointer; }
  #hueSlider { width:20px; height:200px; cursor:pointer; margin-left:10px; }
  #opacitySlider { width:200px; margin-top:8px; }
  #svCursor {
    position:absolute;
    width:10px;
    height:10px;
    border:2px solid #fff;
    border-radius:50%;
    pointer-events:none;
    transform:translate(-5px,-5px);
  }
  #hueCursor {
    position:absolute;
    width:26px;
    height:4px;
    background:#fff;
    pointer-events:none;
    transform:translateX(-3px);
  }
  #pickerButtons { display:flex; gap:10px; margin-top:10px; }
  #previewContainer { display:flex; align-items:center; gap:8px; margin-top:8px; }
  #previewContainer span { font-size:0.85rem; color:#ccc; }
  #previewSwatch { width:36px; height:24px; border:2px solid #888; cursor:pointer; }
  #historyRow { display:flex; gap:6px; margin-top:8px; flex-wrap:wrap; }
  .historySwatch {
    width:24px;
    height:24px;
    border:1px solid #666;
    cursor:pointer;
  }
</style>
</head>
<body>
<h2 style="margin:8px 0; text-align:center; width:100%;">8-Bit Automatron</h2>

<div id="toolbar-top">
  <div class="control">Pixel Size: <input type="number" id="pixelSize" value="200" min="1" max="1024" style="width:4em;"></div>
  <div class="control">Aspect Ratio:
    <select id="aspect">
      <option value="1:1">1:1</option>
      <option value="4:3">4:3</option>
      <option value="3:4">3:4</option>
      <option value="16:9">16:9</option>
      <option value="4:1">Banner</option>
    </select>
  </div>
  <div class="control">Background:
    <div id="bgSwatch" class="swatch" style="background:#000000; margin-left:6px;"></div>
    <input type="hidden" id="bgColorInput" value="#000000">
    <input type="color" id="bgColorPicker" value="#000000" title="Background color" style="margin-left:8px;">
    <label style="margin-left:8px;"><input type="checkbox" id="transparentBg" checked> Transparent</label>
  </div>
  <div class="control">Pen Size: <input id="penSize" type="number" value="4" min="1" max="20" style="width:4em;"></div>
  <div class="control">Pen Color:
    <div id="penSwatch" class="swatch" style="background:#ffffff; margin-left:6px;"></div>
    <input type="hidden" id="penColorInput" value="#ffffff">
    <input type="color" id="penColorPicker" value="#ffffff" title="Pen color" style="margin-left:8px;">
  </div>
  <div class="control"><label><input type="checkbox" id="penEraser"> Eraser Mode</label></div>
</div>

<div id="toolbar-bottom">
  <div class="toolbar-row">
    <button id="undoBtn" class="button-control">Undo</button>
    <button id="resetBtn" class="button-control">Reset</button>
  </div>
  <div class="toolbar-row">
    <button id="uploadBtn" class="button-control">Upload PNG</button>
    <input type="file" id="uploadInput" accept="image/png" style="display:none;">
    <button id="bitifyBtn" class="button-control">8-Bitify</button>
    <button id="colorPickerTool" class="button-control" title="Pick a color from the canvas">Pick Color</button>
    <button id="exportBtn" class="button-control">Export PNG</button>
    <div class="control" style="min-width:200px;">
      File Name: <input type="text" id="fileNameInput" value="design" style="margin-left:6px; width:120px;">
    </div>
  </div>
</div>

<div id="canvasWrapper">
  <canvas id="canvas"></canvas>
</div>

<div id="zoomControls">
  <button id="zoomOutBtn">-</button>
  <div id="zoomDisplay">100%</div>
  <button id="zoomInBtn">+</button>
</div>

<!-- HSV Color Picker anchored under swatch -->
<div id="customColorPicker">
  <div style="display:flex; position:relative;">
    <div style="position:relative;">
      <canvas id="svSquare"></canvas>
      <div id="svCursor"></div>
    </div>
    <div style="position:relative; margin-left:10px;">
      <canvas id="hueSlider"></canvas>
      <div id="hueCursor"></div>
    </div>
  </div>

  <input type="range" id="opacitySlider" min="0" max="1" step="0.01" value="1">

  <div style="margin-top:6px;">Hex: <input id="customHex" type="text" style="width:90px;"></div>
  <div style="margin-top:6px;">
    R:<input id="rInput" type="number" min="0" max="255" style="width:4em;">
    G:<input id="gInput" type="number" min="0" max="255" style="width:4em;">
    B:<input id="bInput" type="number" min="0" max="255" style="width:4em;">
  </div>

  <div id="previewContainer">
    <span>Preview:</span>
    <div id="previewSwatch"></div>
  </div>

  <div id="historyRow"></div>

  <div id="pickerButtons">
    <button id="applyColor" class="button-control" style="min-width:100px;">Apply</button>
    <button id="cancelColor" class="button-control" style="min-width:100px;">Cancel</button>
  </div>
</div>

<script>
// =====================
// Canvas + Drawing Core
// =====================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

const pixelSizeInput = document.getElementById('pixelSize');
const aspectSelect = document.getElementById('aspect');
const bgSwatch = document.getElementById('bgSwatch');
const bgColorInput = document.getElementById('bgColorInput');
const bgColorPicker = document.getElementById('bgColorPicker');
const transparentToggle = document.getElementById('transparentBg');
const penSizeInput = document.getElementById('penSize');
const penSwatch = document.getElementById('penSwatch');
const penColorInput = document.getElementById('penColorInput');
const penColorPicker = document.getElementById('penColorPicker');
const penEraserToggle = document.getElementById('penEraser');
const uploadBtn = document.getElementById('uploadBtn');
const uploadInput = document.getElementById('uploadInput');
const bitifyBtn = document.getElementById('bitifyBtn');
const fileNameInput = document.getElementById('fileNameInput');
const colorPickerToolBtn = document.getElementById('colorPickerTool');
const zoomInBtn = document.getElementById('zoomInBtn');
const zoomOutBtn = document.getElementById('zoomOutBtn');
const zoomDisplay = document.getElementById('zoomDisplay');

let baseSize = 200;
const maxSize = 1024;
let gridW = baseSize;
let gridH = baseSize;
let zoomLevel = 1;
const minZoom = 0.5;
const maxZoom = 8;

let drawing = false;
let penSize = 4;
let penColor = '#ffffff';
let historyStack = [];
let uploadedImage = null;
let pickColorMode = false;

function clamp(val,min,max){return Math.max(min,Math.min(max,val));}

function clearCanvasContents(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (!transparentToggle.checked) {
    ctx.fillStyle = bgColorInput.value;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
}

function updateCanvasSize(){
  let v = parseInt(pixelSizeInput.value,10);
  if (isNaN(v)) v = baseSize;
  v = clamp(v,1,maxSize);
  baseSize = v;
  pixelSizeInput.value = v;

  const [aw,ah] = aspectSelect.value.split(':').map(Number);
  if (aw >= ah) {
    gridW = clamp(v,1,maxSize);
    gridH = clamp(Math.round(v * ah / aw),1,maxSize);
  } else {
    gridH = clamp(v,1,maxSize);
    gridW = clamp(Math.round(v * aw / ah),1,maxSize);
  }

  canvas.width = gridW;
  canvas.height = gridH;
  ctx.imageSmoothingEnabled = false;
  updateCanvasZoom();
}

pixelSizeInput.addEventListener('change', updateCanvasSize);
aspectSelect.addEventListener('change', updateCanvasSize);

function updateCanvasBackground(){
  if (transparentToggle.checked) {
    canvas.style.backgroundColor = 'transparent';
  } else {
    canvas.style.backgroundColor = bgColorInput.value;
  }
}

transparentToggle.addEventListener('change', updateCanvasBackground);

function updateCanvasZoom(){
  canvas.style.width = (gridW * zoomLevel) + 'px';
  canvas.style.height = (gridH * zoomLevel) + 'px';
  zoomDisplay.textContent = Math.round(zoomLevel * 100) + '%';
}

function setZoom(level){
  zoomLevel = clamp(level, minZoom, maxZoom);
  updateCanvasZoom();
}

zoomInBtn.addEventListener('click', () => setZoom(zoomLevel + 0.25));
zoomOutBtn.addEventListener('click', () => setZoom(zoomLevel - 0.25));

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const delta = e.deltaY < 0 ? 0.1 : -0.1;
  setZoom(zoomLevel + delta);
}, { passive: false });

penSizeInput.addEventListener('change', e => {
  let v = parseInt(e.target.value,10);
  if (isNaN(v) || v < 1) v = 1;
  penSize = v;
  penSizeInput.value = v;
});

bgColorPicker.addEventListener('input', () => {
  const hex = bgColorPicker.value;
  bgColorInput.value = hex;
  bgSwatch.style.backgroundColor = hex;
  updateCanvasBackground();
});

penColorPicker.addEventListener('input', () => {
  const hex = penColorPicker.value;
  penColorInput.value = hex;
  penSwatch.style.backgroundColor = hex;
  penColor = hex;
});

function saveState(){
  historyStack.push(canvas.toDataURL());
  if (historyStack.length > 50) historyStack.shift();
}

function renderImageToCanvas(img){
  if (!img) return;
  saveState();
  clearCanvasContents();

  const tmp = document.createElement('canvas');
  tmp.width = canvas.width;
  tmp.height = canvas.height;
  const tctx = tmp.getContext('2d');
  tctx.imageSmoothingEnabled = false;

  if (!transparentToggle.checked) {
    tctx.fillStyle = bgColorInput.value;
    tctx.fillRect(0, 0, tmp.width, tmp.height);
  } else {
    tctx.clearRect(0, 0, tmp.width, tmp.height);
  }

  const imgRatio = img.width / img.height;
  const canvasRatio = canvas.width / canvas.height;
  let drawWidth, drawHeight;
  if (imgRatio > canvasRatio) {
    drawWidth = canvas.width;
    drawHeight = Math.max(1, Math.round(canvas.width / imgRatio));
  } else {
    drawHeight = canvas.height;
    drawWidth = Math.max(1, Math.round(canvas.height * imgRatio));
  }

  const dx = Math.round((canvas.width - drawWidth) / 2);
  const dy = Math.round((canvas.height - drawHeight) / 2);
  tctx.drawImage(img, dx, dy, drawWidth, drawHeight);

  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(tmp, 0, 0);
}

function quantizeChannel(v){
  const step = 85; // 4 levels (0, 85, 170, 255)
  return Math.max(0, Math.min(255, Math.round(v / step) * step));
}

function eightBitifyCanvas(){
  saveState();
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    data[i] = quantizeChannel(data[i]);
    data[i + 1] = quantizeChannel(data[i + 1]);
    data[i + 2] = quantizeChannel(data[i + 2]);
  }
  ctx.putImageData(imageData, 0, 0);
}

function canvasCoords(e){
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width / rect.width);
  const y = (e.clientY - rect.top) * (canvas.height / rect.height);
  return {x,y};
}

function paint(e){
  const {x,y} = canvasCoords(e);
  const ix = Math.floor(x);
  const iy = Math.floor(y);
  const erasing = penEraserToggle.checked;
  if (!erasing) {
    ctx.fillStyle = penColor;
  } else if (!transparentToggle.checked) {
    ctx.fillStyle = bgColorInput.value;
  }
  for (let dx = -penSize; dx <= penSize; dx++){
    for (let dy = -penSize; dy <= penSize; dy++){
      const px = ix + dx;
      const py = iy + dy;
      if (erasing){
        if (transparentToggle.checked){
          ctx.clearRect(px, py, 1, 1);
        } else {
          ctx.fillRect(px, py, 1, 1);
        }
      } else {
        ctx.fillRect(px, py, 1, 1);
      }
    }
  }
}

function setPickColorMode(active){
  pickColorMode = active;
  colorPickerToolBtn.classList.toggle('active', active);
  canvas.style.cursor = active ? 'copy' : 'crosshair';
}

function sampleCanvasColor(e){
  if (canvas.width === 0 || canvas.height === 0) {
    setPickColorMode(false);
    return;
  }
  const {x,y} = canvasCoords(e);
  const ix = clamp(Math.floor(x), 0, canvas.width - 1);
  const iy = clamp(Math.floor(y), 0, canvas.height - 1);
  const data = ctx.getImageData(ix, iy, 1, 1).data;
  let hex;
  if (data[3] === 0) {
    hex = transparentToggle.checked ? penColor : bgColorInput.value;
  } else {
    hex = RGBtoHex(data[0], data[1], data[2]);
  }
  penColor = hex;
  penColorInput.value = hex;
  penColorPicker.value = hex;
  penSwatch.style.backgroundColor = hex;
  pushHistory(hex);
  if (picker.style.display === 'block') {
    const rgb = hexToRGB(hex);
    hsv = RGBtoHSV(rgb.r,rgb.g,rgb.b);
    drawHue();
    drawSV();
    updatePickerFields();
  } else {
    updatePreviewSwatch(hex);
  }
  setPickColorMode(false);
}

canvas.addEventListener('mousedown', e => {
  if (pickColorMode) {
    sampleCanvasColor(e);
    return;
  }
  drawing = true;
  saveState();          // stroke-level undo
  paint(e);
});
canvas.addEventListener('mousemove', e => {
  if (pickColorMode) return;
  if (drawing) paint(e);
});
canvas.addEventListener('mouseup', () => drawing=false);
canvas.addEventListener('mouseleave', () => drawing=false);

// Undo / Reset / Export
const undoBtn = document.getElementById('undoBtn');
const resetBtn = document.getElementById('resetBtn');
const exportBtn = document.getElementById('exportBtn');

undoBtn.addEventListener('click', () => {
  if (!historyStack.length) return;
  const data = historyStack.pop();
  const img = new Image();
  img.onload = () => {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img,0,0);
  };
  img.src = data;
});

resetBtn.addEventListener('click', () => {
  const msg = "Hold up pixel wizard, this will vaporize your masterpiece into the digital void and give you a fresh, empty canvas. Proceed?";
  if (!confirm(msg)) return;

  // Hard clear: wipe pixels and history so nothing can be undone back
  clearCanvasContents();
  historyStack = [];
  uploadedImage = null;
});

exportBtn.addEventListener('click', () => {
  const exp = document.createElement('canvas');
  exp.width = canvas.width;
  exp.height = canvas.height;
  const ectx = exp.getContext('2d');
  if (!transparentToggle.checked) {
    ectx.fillStyle = bgColorInput.value;
    ectx.fillRect(0,0,exp.width,exp.height);
  }
  ectx.drawImage(canvas,0,0);
  const link = document.createElement('a');
  let name = fileNameInput.value.trim() || 'design';
  if (!name.toLowerCase().endsWith('.png')) name += '.png';
  link.download = name;
  link.href = exp.toDataURL('image/png');
  link.click();
});

uploadBtn.addEventListener('click', () => uploadInput.click());

uploadInput.addEventListener('change', e => {
  const file = e.target.files && e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = ev => {
    const img = new Image();
    img.onload = () => {
      uploadedImage = img;
      renderImageToCanvas(img);
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
  uploadInput.value = '';
});

bitifyBtn.addEventListener('click', () => {
  if (canvas.width === 0 || canvas.height === 0) return;
  eightBitifyCanvas();
});

colorPickerToolBtn.addEventListener('click', () => {
  setPickColorMode(!pickColorMode);
});

window.addEventListener('keydown', e => {
  if (e.key === 'Escape' && pickColorMode) {
    setPickColorMode(false);
  }
});

// ==========================
// HSV Color Picker subsystem
// ==========================
const picker = document.getElementById('customColorPicker');
const sv = document.getElementById('svSquare');
const hue = document.getElementById('hueSlider');
const svCtx = sv.getContext('2d');
const hueCtx = hue.getContext('2d');
const svCursor = document.getElementById('svCursor');
const hueCursor = document.getElementById('hueCursor');
const opacitySlider = document.getElementById('opacitySlider');
const customHex = document.getElementById('customHex');
const rInput = document.getElementById('rInput');
const gInput = document.getElementById('gInput');
const bInput = document.getElementById('bInput');
const applyColor = document.getElementById('applyColor');
const cancelColor = document.getElementById('cancelColor');
const historyRow = document.getElementById('historyRow');
const previewSwatch = document.getElementById('previewSwatch');

sv.width = 200; sv.height = 200;
hue.width = 20; hue.height = 200;

let hsv = {h:0, s:1, v:1};
let currentPickerTarget = null; // 'bg' or 'pen'
let historyColors = [];

function HSVtoRGB(h,s,v){
  let f = n => {
    let k = (n + h*6) % 6;
    return v - v*s*Math.max(Math.min(k,4-k,1),0);
  };
  return {
    r: Math.round(f(5)*255),
    g: Math.round(f(3)*255),
    b: Math.round(f(1)*255)
  };
}

function RGBtoHSV(r,g,b){
  r/=255; g/=255; b/=255;
  const max = Math.max(r,g,b), min = Math.min(r,g,b);
  const d = max-min;
  let h;
  const v = max;
  const s = max === 0 ? 0 : d/max;
  if (d === 0) h = 0;
  else if (max === r) h = ((g-b)/d + (g<b?6:0))/6;
  else if (max === g) h = ((b-r)/d + 2)/6;
  else h = ((r-g)/d + 4)/6;
  return {h,s,v};
}

function hexToRGB(hex){
  hex = hex.replace('#','');
  if (hex.length !== 6) return {r:255,g:255,b:255};
  return {
    r: parseInt(hex.slice(0,2),16),
    g: parseInt(hex.slice(2,4),16),
    b: parseInt(hex.slice(4,6),16)
  };
}

function RGBtoHex(r,g,b){
  return '#' + [r,g,b].map(v=>{
    const n = clamp(v,0,255)|0;
    return n.toString(16).padStart(2,'0');
  }).join('');
}

function drawHue(){
  const grad = hueCtx.createLinearGradient(0,0,0,hue.height);
  grad.addColorStop(0,'#f00');
  grad.addColorStop(0.17,'#ff0');
  grad.addColorStop(0.33,'#0f0');
  grad.addColorStop(0.5,'#0ff');
  grad.addColorStop(0.67,'#00f');
  grad.addColorStop(0.83,'#f0f');
  grad.addColorStop(1,'#f00');
  hueCtx.fillStyle = grad;
  hueCtx.fillRect(0,0,hue.width,hue.height);
}

function drawSV(){
  const rgb = HSVtoRGB(hsv.h,1,1);
  let gradX = svCtx.createLinearGradient(0,0,sv.width,0);
  gradX.addColorStop(0,'#ffffff');
  gradX.addColorStop(1,`rgb(${rgb.r},${rgb.g},${rgb.b})`);
  svCtx.fillStyle = gradX;
  svCtx.fillRect(0,0,sv.width,sv.height);

  let gradY = svCtx.createLinearGradient(0,0,0,sv.height);
  gradY.addColorStop(0,'rgba(0,0,0,0)');
  gradY.addColorStop(1,'#000000');
  svCtx.fillStyle = gradY;
  svCtx.fillRect(0,0,sv.width,sv.height);
}

function updatePickerFields(){
  const rgb = HSVtoRGB(hsv.h,hsv.s,hsv.v);
  const hex = RGBtoHex(rgb.r,rgb.g,rgb.b);
  customHex.value = hex;
  rInput.value = rgb.r;
  gInput.value = rgb.g;
  bInput.value = rgb.b;
  updatePreviewSwatch(hex);

  // cursor positions
  const x = clamp(hsv.s * sv.width, 0, sv.width);
  const y = clamp((1 - hsv.v) * sv.height, 0, sv.height);
  svCursor.style.left = x + 'px';
  svCursor.style.top  = y + 'px';
  svCursor.style.display = 'block';

  const hy = clamp(hsv.h * hue.height, 0, hue.height);
  hueCursor.style.left = (hue.width / 2) + 'px';
  hueCursor.style.top  = hy + 'px';
  hueCursor.style.display = 'block';
}

function openPicker(targetKey, swatch){
  setPickColorMode(false);
  currentPickerTarget = targetKey; // 'bg' or 'pen'
  const rect = swatch.getBoundingClientRect();
  picker.style.left = rect.left + 'px';
  picker.style.top  = (rect.bottom + 4) + 'px';

  picker.style.display = 'block';

  const hex = targetKey === 'bg' ? bgColorInput.value : penColorInput.value;
  const rgb = hexToRGB(hex);
  hsv = RGBtoHSV(rgb.r,rgb.g,rgb.b);
  drawHue();
  drawSV();
  updatePickerFields();
}

function closePicker(){
  picker.style.display = 'none';
  currentPickerTarget = null;
}

function currentHSVHex(){
  const rgb = HSVtoRGB(hsv.h,hsv.s,hsv.v);
  return RGBtoHex(rgb.r,rgb.g,rgb.b);
}

function updatePreviewSwatch(hex = currentHSVHex()){
  previewSwatch.style.backgroundColor = hex;
  previewSwatch.title = `Apply ${hex}`;
}

function setHSVFromSVEvent(e){
  const rect = sv.getBoundingClientRect();
  let x = clamp((e.clientX - rect.left) / rect.width, 0, 1);
  let y = clamp((e.clientY - rect.top) / rect.height, 0, 1);
  hsv.s = x;
  hsv.v = 1 - y;
  drawSV();
  updatePickerFields();
}

function setHSVFromHueEvent(e){
  const rect = hue.getBoundingClientRect();
  let y = clamp((e.clientY - rect.top) / rect.height, 0, 1);
  hsv.h = y;
  drawHue();
  drawSV();
  updatePickerFields();
}

sv.addEventListener('mousedown', e => {
  setHSVFromSVEvent(e);
  function move(ev){ setHSVFromSVEvent(ev); }
  function up(){ window.removeEventListener('mousemove',move); window.removeEventListener('mouseup',up); }
  window.addEventListener('mousemove',move);
  window.addEventListener('mouseup',up);
});

hue.addEventListener('mousedown', e => {
  setHSVFromHueEvent(e);
  function move(ev){ setHSVFromHueEvent(ev); }
  function up(){ window.removeEventListener('mousemove',move); window.removeEventListener('mouseup',up); }
  window.addEventListener('mousemove',move);
  window.addEventListener('mouseup',up);
});

// Hex and RGB field sync
customHex.addEventListener('input', () => {
  let v = customHex.value.trim();
  if (!v.startsWith('#')) v = '#' + v;
  if (/^#([0-9A-Fa-f]{6})$/.test(v)){
    const rgb = hexToRGB(v);
    hsv = RGBtoHSV(rgb.r,rgb.g,rgb.b);
    drawHue();
    drawSV();
    updatePickerFields();
  }
});

[rInput,gInput,bInput].forEach(inp => {
  inp.addEventListener('change', () => {
    const r = parseInt(rInput.value,10)||0;
    const g = parseInt(gInput.value,10)||0;
    const b = parseInt(bInput.value,10)||0;
    hsv = RGBtoHSV(r,g,b);
    drawHue();
    drawSV();
    updatePickerFields();
  });
});

// History
function pushHistory(color){
  historyColors = historyColors.filter(c => c !== color);
  historyColors.unshift(color);
  if (historyColors.length > 8) historyColors.pop();
  historyRow.innerHTML = '';
  historyColors.forEach(col => {
    const d = document.createElement('div');
    d.className = 'historySwatch';
    d.style.backgroundColor = col;
    d.addEventListener('click', () => {
      const rgb = hexToRGB(col);
      hsv = RGBtoHSV(rgb.r,rgb.g,rgb.b);
      drawHue();
      drawSV();
      updatePickerFields();
    });
    historyRow.appendChild(d);
  });
}

function applySelectedColor(){
  if (!currentPickerTarget) return;
  const hex = currentHSVHex();
  pushHistory(hex);
  if (currentPickerTarget === 'bg'){
    bgColorInput.value = hex;
    bgSwatch.style.backgroundColor = hex;
    bgColorPicker.value = hex;
    updateCanvasBackground();
  } else if (currentPickerTarget === 'pen'){
    penColorInput.value = hex;
    penSwatch.style.backgroundColor = hex;
    penColorPicker.value = hex;
    penColor = hex;
  }
  closePicker();
}

applyColor.addEventListener('click', applySelectedColor);
previewSwatch.addEventListener('click', applySelectedColor);

cancelColor.addEventListener('click', closePicker);

bgSwatch.addEventListener('click', () => openPicker('bg', bgSwatch));
penSwatch.addEventListener('click', () => openPicker('pen', penSwatch));

// ============
// Initialization
// ============
updatePreviewSwatch(penColor);
updateCanvasSize();
updateCanvasBackground();

// load default image placeholder centered (optional; here we just clear)
clearCanvasContents();

</script>
</body>
</html>
