<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>8-Bit Automatron</title>
<style>
  body {
    font-family: monospace;
    background:#222;
    color:#eee;
    margin:0;
    padding:0;
    min-height:100vh;
    width:100%;
    overflow-x:hidden;
    display:flex;
    flex-direction:column;
  }
  #toolbar-top, #toolbar-bottom {
    padding:10px;
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    justify-content:center;
    align-items:center;
    background:#111;
    z-index:2;
  }
  #toolbar-bottom { padding-top:0; flex-direction:column; }

  .toolbar-row {
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    justify-content:center;
    width:100%;
  }

  canvas {
    image-rendering: pixelated;
    background:transparent;
    cursor:crosshair;
  }

  .control {
    background:#333;
    padding:6px 10px;
    border-radius:4px;
    color:#fff;
    border:1px solid #555;
    display:flex;
    align-items:center;
    justify-content:center;
    min-height:36px;
    height:36px;
    min-width:160px;
    box-sizing:border-box;
    font-size:0.9rem;
  }
  .control input,
  .control select {
    font-family:inherit;
    font-size:0.9rem;
    margin-left:6px;
    height:24px;
  }

  .button-control {
    cursor:pointer;
    background:#333;
    border:1px solid #555;
    border-radius:4px;
    padding:6px 10px;
    color:#fff;
    min-height:36px;
    min-width:160px;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .button-control:hover { background:#444; }
  .button-control:active { background:#0a0; border-color:#0f0; }
  .button-control.active {
    background:#225;
    border-color:#4af;
  }

  .swatch {
    width:36px;
    height:24px;
    border:1px solid #444;
    cursor:pointer;
  }

  #zoomControls {
    display:flex;
    justify-content:center;
    align-items:center;
    gap:10px;
    margin-bottom:16px;
  }

  #zoomControls button {
    width:40px;
    height:32px;
    font-size:1.2rem;
    cursor:pointer;
    background:#333;
    border:1px solid #555;
    border-radius:4px;
    color:#fff;
  }

  #zoomDisplay {
    min-width:60px;
    text-align:center;
  }

  #canvasWrapper {
    flex:1;
    display:flex;
    justify-content:center;
    align-items:center;
    padding:20px;
    box-sizing:border-box;
    overflow:auto;
  }

  #canvasContainer {
    position:relative;
    display:inline-block;
    border:2px solid #666;
  }

  #canvasContainer canvas {
    display:block;
  }

  #gridOverlay,
  #cursorOverlay {
    position:absolute;
    top:0;
    left:0;
    pointer-events:none;
  }

  #gridOverlay {
    background-image:
      linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
      linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
    background-repeat:repeat;
    box-sizing:border-box;
    z-index:1;
  }

  #cursorOverlay {
    border:2px solid #0ff;
    box-sizing:border-box;
    z-index:2;
    background:rgba(0,255,255,0.12);
  }

  /* Color picker */
  #customColorPicker {
    position:fixed;
    background:#333;
    padding:12px;
    border:1px solid #666;
    border-radius:6px;
    display:none;
    z-index:10;
  }
  #svSquare { width:200px; height:200px; cursor:pointer; }
  #hueSlider { width:20px; height:200px; cursor:pointer; margin-left:10px; }
  #opacitySlider { width:200px; margin-top:8px; }
  #svCursor {
    position:absolute;
    width:10px;
    height:10px;
    border:2px solid #fff;
    border-radius:50%;
    pointer-events:none;
    transform:translate(-5px,-5px);
  }
  #hueCursor {
    position:absolute;
    width:26px;
    height:4px;
    background:#fff;
    pointer-events:none;
    transform:translateX(-3px);
  }
  #pickerButtons { display:flex; gap:10px; margin-top:10px; }
  #previewContainer { display:flex; align-items:center; gap:8px; margin-top:8px; }
  #previewContainer span { font-size:0.85rem; color:#ccc; }
  #previewSwatch { width:36px; height:24px; border:2px solid #888; cursor:pointer; }
  #historyRow { display:flex; gap:6px; margin-top:8px; flex-wrap:wrap; }
  .historySwatch {
    width:24px;
    height:24px;
    border:1px solid #666;
    cursor:pointer;
  }

  @media (max-width: 900px) {
    body {
      align-items:stretch;
    }

    #toolbar-top, #toolbar-bottom {
      flex-direction:column;
      align-items:stretch;
      gap:12px;
    }

    .toolbar-row {
      flex-direction:column;
      align-items:stretch;
      gap:12px;
    }

    .control,
    .button-control {
      width:100%;
      min-width:0;
    }

    .control {
      flex-direction:column;
      align-items:flex-start;
      gap:6px;
    }

    .control input,
    .control select {
      margin-left:0;
      width:100%;
      min-width:0;
    }

    #canvasWrapper {
      padding:12px;
    }

    #canvasContainer {
      max-width:100%;
    }

    h2 {
      font-size:1.5rem;
      padding:0 12px;
    }

    #customColorPicker {
      width:calc(100% - 24px);
      max-width:360px;
    }

    #customColorPicker > div:first-child {
      flex-direction:column;
      align-items:center;
      gap:12px;
    }

    #svSquare,
    #opacitySlider {
      width:100%;
      max-width:260px;
    }

    #hueSlider {
      margin-left:0;
      margin-top:10px;
    }

    #hueCursor {
      transform:translateX(-3px);
    }

    #pickerButtons {
      flex-direction:column;
      width:100%;
    }

    #pickerButtons .button-control {
      width:100%;
    }
  }
</style>
</head>
<body>
<h2 style="margin:8px 0; text-align:center; width:100%;">8-Bit Automatron</h2>

<div id="toolbar-top">
  <div class="control">Pixel Size: <input type="number" id="pixelSize" value="200" min="1" max="1024" style="width:4em;"></div>
  <div class="control">Aspect Ratio:
    <select id="aspect">
      <option value="1:1">1:1</option>
      <option value="4:3">4:3</option>
      <option value="3:4">3:4</option>
      <option value="16:9">16:9</option>
      <option value="4:1">Banner</option>
    </select>
  </div>
  <div class="control">Zoom: <input type="number" id="zoomLevel" value="4" min="1" max="32" style="width:4em;"></div>
  <div class="control">Background:
    <div id="bgSwatch" class="swatch" style="background:#000000; margin-left:6px;"></div>
    <input type="hidden" id="bgColorInput" value="#000000">
    <label style="margin-left:8px;"><input type="checkbox" id="transparentBg" checked> Transparent</label>
  </div>
  <div class="control">Pen Size: <input id="penSize" type="number" value="4" min="1" max="20" style="width:4em;"></div>
  <div class="control">Pen Color:
    <div id="penSwatch" class="swatch" style="background:#ffffff; margin-left:6px;"></div>
    <input type="hidden" id="penColorInput" value="#ffffff">
  </div>
  <div class="control"><label><input type="checkbox" id="penEraser"> Eraser Mode</label></div>
</div>

<div id="toolbar-bottom">
  <div class="toolbar-row">
    <button id="undoBtn" class="button-control">Undo</button>
    <button id="resetBtn" class="button-control">Reset</button>
  </div>
  <div class="toolbar-row">
    <button id="uploadBtn" class="button-control">Upload PNG</button>
    <input type="file" id="uploadInput" accept="image/png" style="display:none;">
    <button id="bitifyBtn" class="button-control">8-Bitify</button>
    <button id="colorPickerTool" class="button-control" title="Pick a color from the canvas">Pick Color</button>
    <button id="exportBtn" class="button-control">Export PNG</button>
    <div class="control" style="min-width:200px;">
      File Name: <input type="text" id="fileNameInput" value="design" style="margin-left:6px; width:120px;">
    </div>
  </div>
</div>

<div id="canvasWrapper">
  <div id="canvasContainer">
    <canvas id="canvas"></canvas>
    <div id="gridOverlay"></div>
    <div id="cursorOverlay"></div>
  </div>
</div>

<div id="zoomControls">
  <button id="zoomOutBtn">-</button>
  <div id="zoomDisplay">100%</div>
  <button id="zoomInBtn">+</button>
</div>

<!-- HSV Color Picker anchored under swatch -->
<div id="customColorPicker">
  <div style="display:flex; position:relative;">
    <div style="position:relative;">
      <canvas id="svSquare"></canvas>
      <div id="svCursor"></div>
    </div>
    <div style="position:relative; margin-left:10px;">
      <canvas id="hueSlider"></canvas>
      <div id="hueCursor"></div>
    </div>
  </div>

  <input type="range" id="opacitySlider" min="0" max="1" step="0.01" value="1">

  <div style="margin-top:6px;">Hex: <input id="customHex" type="text" style="width:90px;"></div>
  <div style="margin-top:6px;">
    R:<input id="rInput" type="number" min="0" max="255" style="width:4em;">
    G:<input id="gInput" type="number" min="0" max="255" style="width:4em;">
    B:<input id="bInput" type="number" min="0" max="255" style="width:4em;">
  </div>

  <div id="previewContainer">
    <span>Preview:</span>
    <div id="previewSwatch"></div>
  </div>

  <div id="historyRow"></div>

  <div id="pickerButtons">
    <button id="applyColor" class="button-control" style="min-width:100px;">Apply</button>
    <button id="cancelColor" class="button-control" style="min-width:100px;">Cancel</button>
  </div>
</div>

<script>
// =====================
// Canvas + Drawing Core
// =====================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

const pixelSizeInput = document.getElementById('pixelSize');
const aspectSelect = document.getElementById('aspect');
const bgSwatch = document.getElementById('bgSwatch');
const bgColorInput = document.getElementById('bgColorInput');
const transparentToggle = document.getElementById('transparentBg');
const penSizeInput = document.getElementById('penSize');
const penSwatch = document.getElementById('penSwatch');
const penColorInput = document.getElementById('penColorInput');
const penEraserToggle = document.getElementById('penEraser');
const uploadBtn = document.getElementById('uploadBtn');
const uploadInput = document.getElementById('uploadInput');
const bitifyBtn = document.getElementById('bitifyBtn');
const zoomInput = document.getElementById('zoomLevel');
const fileNameInput = document.getElementById('fileNameInput');
const colorPickerToolBtn = document.getElementById('colorPickerTool');
const canvasContainer = document.getElementById('canvasContainer');
const gridOverlayEl = document.getElementById('gridOverlay');
const cursorOverlayEl = document.getElementById('cursorOverlay');
const picker = document.getElementById('customColorPicker');
const sv = document.getElementById('svSquare');
const hue = document.getElementById('hueSlider');
const svCursor = document.getElementById('svCursor');
const hueCursor = document.getElementById('hueCursor');
const customHex = document.getElementById('customHex');
const rInput = document.getElementById('rInput');
const gInput = document.getElementById('gInput');
const bInput = document.getElementById('bInput');
const previewSwatch = document.getElementById('previewSwatch');
const historyRow = document.getElementById('historyRow');
const applyColorBtn = document.getElementById('applyColor');
const cancelColorBtn = document.getElementById('cancelColor');

const svCtx = sv ? sv.getContext('2d') : null;
const hueCtx = hue ? hue.getContext('2d') : null;

if (sv) {
  sv.width = sv.clientWidth;
  sv.height = sv.clientHeight;
}
if (hue) {
  hue.width = hue.clientWidth;
  hue.height = hue.clientHeight;
}

let baseSize = 200;
const maxSize = 1024;
let gridW = baseSize;
let gridH = baseSize;
let zoomLevel = 1;
const minZoom = 0.5;
const maxZoom = 8;

let drawing = false;
let penSize = 4;
let penColor = '#ffffff';
let historyStack = [];
let uploadedImage = null;
let zoom = clamp(parseInt(zoomInput.value, 10) || 1, 1, 32);
zoomInput.value = zoom;
let cursorX = 0;
let cursorY = 0;
let pickColorMode = false;
let historyColors = [];
let hsv = {h: 0, s: 0, v: 1};
let currentPickerTarget = null;

function clamp(val,min,max){return Math.max(min,Math.min(max,val));}

function normalizeHex(hex){
  if (typeof hex !== 'string') return '#000000';
  let value = hex.trim();
  if (!value) return '#000000';
  if (value[0] === '#') value = value.slice(1);
  if (/^[0-9a-f]{3}$/i.test(value)) {
    value = value.split('').map(ch => ch + ch).join('');
  }
  if (!/^[0-9a-f]{6}$/i.test(value)) {
    return '#000000';
  }
  return '#' + value.toLowerCase();
}

function clearCanvasContents(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (!transparentToggle.checked) {
    ctx.fillStyle = bgColorInput.value;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
}

function updateCursorOverlayPosition(){
  if (!cursorOverlayEl) return;
  const maxX = Math.max(0, canvas.width - penSize);
  const maxY = Math.max(0, canvas.height - penSize);
  cursorX = clamp(cursorX, 0, maxX);
  cursorY = clamp(cursorY, 0, maxY);
  cursorOverlayEl.style.transform = `translate(${cursorX * zoom}px, ${cursorY * zoom}px)`;
}

function getSnappedCoords(x, y){
  const size = Math.max(1, penSize);
  const snapX = Math.floor(x / size) * size;
  const snapY = Math.floor(y / size) * size;
  const maxX = Math.max(0, canvas.width - size);
  const maxY = Math.max(0, canvas.height - size);
  return {
    x: clamp(snapX, 0, maxX),
    y: clamp(snapY, 0, maxY)
  };
}

function setCursorPositionFromCoords(x, y){
  if (!canvas.width || !canvas.height) return;
  const snapped = getSnappedCoords(x, y);
  cursorX = snapped.x;
  cursorY = snapped.y;
  updateCursorOverlayPosition();
}

function applyZoom(){
  const displayWidth = canvas.width * zoom;
  const displayHeight = canvas.height * zoom;
  canvas.style.width = displayWidth + 'px';
  canvas.style.height = displayHeight + 'px';
  canvasContainer.style.width = displayWidth + 'px';
  canvasContainer.style.height = displayHeight + 'px';

  if (gridOverlayEl) {
    gridOverlayEl.style.width = displayWidth + 'px';
    gridOverlayEl.style.height = displayHeight + 'px';
    gridOverlayEl.style.opacity = zoom > 1 ? '1' : '0.3';
  }

  updateOverlaySizing();
}

function updateOverlaySizing(){
  if (gridOverlayEl) {
    const size = Math.max(1, penSize) * zoom;
    const value = `${size}px ${size}px`;
    gridOverlayEl.style.backgroundSize = `${value}, ${value}`;
    gridOverlayEl.style.backgroundPosition = '0px 0px, 0px 0px';
  }
  if (cursorOverlayEl) {
    const cursorSize = Math.max(1, penSize) * zoom;
    cursorOverlayEl.style.width = cursorSize + 'px';
    cursorOverlayEl.style.height = cursorSize + 'px';
  }
  updateCursorOverlayPosition();
}

function setZoomLevel(value){
  const parsed = parseInt(value, 10);
  zoom = clamp(isNaN(parsed) ? zoom : parsed, 1, 32);
  zoomInput.value = zoom;
  applyZoom();
}

function updateCanvasSize(){
  let v = parseInt(pixelSizeInput.value,10);
  if (isNaN(v)) v = baseSize;
  v = clamp(v,1,maxSize);
  baseSize = v;
  pixelSizeInput.value = v;

  const [aw,ah] = aspectSelect.value.split(':').map(Number);
  if (aw >= ah) {
    gridW = clamp(v,1,maxSize);
    gridH = clamp(Math.round(v * ah / aw),1,maxSize);
  } else {
    gridH = clamp(v,1,maxSize);
    gridW = clamp(Math.round(v * aw / ah),1,maxSize);
  }

  canvas.width = gridW;
  canvas.height = gridH;
  ctx.imageSmoothingEnabled = false;
  updateCursorOverlayPosition();
  applyZoom();
}

pixelSizeInput.addEventListener('change', updateCanvasSize);
aspectSelect.addEventListener('change', updateCanvasSize);
zoomInput.addEventListener('change', e => setZoomLevel(e.target.value));
zoomInput.addEventListener('input', e => setZoomLevel(e.target.value));

function updateCanvasBackground(){
  if (transparentToggle.checked) {
    canvas.style.backgroundColor = 'transparent';
  } else {
    canvas.style.backgroundColor = bgColorInput.value;
  }
}

transparentToggle.addEventListener('change', updateCanvasBackground);

function applyColorToTarget(targetKey, color, options = {}) {
  const normalized = normalizeHex(color);
  const rememberHistory = options.rememberHistory !== false;

  if (targetKey === 'bg') {
    bgColorInput.value = normalized;
    if (bgSwatch) bgSwatch.style.backgroundColor = normalized;
    updateCanvasBackground();
  } else if (targetKey === 'pen') {
    penColorInput.value = normalized;
    penColor = normalized;
    if (penSwatch) penSwatch.style.backgroundColor = normalized;
  } else {
    return;
  }

  if (rememberHistory) {
    pushHistory(normalized);
  }
}

function setPenSize(value){
  let v = parseInt(value,10);
  if (isNaN(v) || v < 1) v = 1;
  penSize = v;
  penSizeInput.value = v;
  const snapped = getSnappedCoords(cursorX, cursorY);
  cursorX = snapped.x;
  cursorY = snapped.y;
  updateOverlaySizing();
}

penSizeInput.addEventListener('change', e => {
  setPenSize(e.target.value);
});
penSizeInput.addEventListener('input', e => {
  setPenSize(e.target.value);
});

function saveState(){
  historyStack.push(canvas.toDataURL());
  if (historyStack.length > 50) historyStack.shift();
}

function renderImageToCanvas(img){
  if (!img) return;
  saveState();
  clearCanvasContents();

  const tmp = document.createElement('canvas');
  tmp.width = canvas.width;
  tmp.height = canvas.height;
  const tctx = tmp.getContext('2d');
  tctx.imageSmoothingEnabled = false;

  if (!transparentToggle.checked) {
    tctx.fillStyle = bgColorInput.value;
    tctx.fillRect(0, 0, tmp.width, tmp.height);
  } else {
    tctx.clearRect(0, 0, tmp.width, tmp.height);
  }

  const imgRatio = img.width / img.height;
  const canvasRatio = canvas.width / canvas.height;
  let drawWidth, drawHeight;
  if (imgRatio > canvasRatio) {
    drawWidth = canvas.width;
    drawHeight = Math.max(1, Math.round(canvas.width / imgRatio));
  } else {
    drawHeight = canvas.height;
    drawWidth = Math.max(1, Math.round(canvas.height * imgRatio));
  }

  const dx = Math.round((canvas.width - drawWidth) / 2);
  const dy = Math.round((canvas.height - drawHeight) / 2);
  tctx.drawImage(img, dx, dy, drawWidth, drawHeight);

  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(tmp, 0, 0);
}

function quantizeChannel(v){
  const step = 85; // 4 levels (0, 85, 170, 255)
  return Math.max(0, Math.min(255, Math.round(v / step) * step));
}

function eightBitifyCanvas(){
  saveState();
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    data[i] = quantizeChannel(data[i]);
    data[i + 1] = quantizeChannel(data[i + 1]);
    data[i + 2] = quantizeChannel(data[i + 2]);
  }
  ctx.putImageData(imageData, 0, 0);
}

function canvasCoords(e){
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width / rect.width);
  const y = (e.clientY - rect.top) * (canvas.height / rect.height);
  return {x,y};
}

function paintAtCoords(x, y){
  const {x: sx, y: sy} = getSnappedCoords(x, y);
  const drawWidth = Math.min(penSize, canvas.width - sx);
  const drawHeight = Math.min(penSize, canvas.height - sy);
  if (drawWidth <= 0 || drawHeight <= 0) return;
  ctx.fillStyle = penColor;
  ctx.fillRect(sx, sy, drawWidth, drawHeight);
}

function paintFromEvent(e){
  const {x,y} = canvasCoords(e);
  setCursorPositionFromCoords(x,y);
  paintAtCoords(cursorX, cursorY);
}

function setPickColorMode(active){
  pickColorMode = active;
  if (colorPickerToolBtn) {
    colorPickerToolBtn.classList.toggle('active', active);
  }
  canvas.style.cursor = active ? 'copy' : 'crosshair';
}

function sampleCanvasColor(e){
  if (canvas.width === 0 || canvas.height === 0) {
    setPickColorMode(false);
    return;
  }
  const {x,y} = canvasCoords(e);
  const ix = clamp(Math.floor(x), 0, canvas.width - 1);
  const iy = clamp(Math.floor(y), 0, canvas.height - 1);
  const data = ctx.getImageData(ix, iy, 1, 1).data;
  let hex;
  if (data[3] === 0) {
    hex = transparentToggle.checked ? penColor : bgColorInput.value;
  } else {
    hex = RGBtoHex(data[0], data[1], data[2]);
  }
  applyColorToTarget('pen', hex);
  setPickColorMode(false);
}

canvas.addEventListener('mousedown', e => {
  if (pickColorMode) {
    sampleCanvasColor(e);
    return;
  }
  drawing = true;
  saveState();          // stroke-level undo
  paintFromEvent(e);
});
canvas.addEventListener('mousemove', e => {
  const {x,y} = canvasCoords(e);
  setCursorPositionFromCoords(x,y);
  if (drawing) paintAtCoords(cursorX, cursorY);
});
canvas.addEventListener('mouseup', () => drawing=false);
canvas.addEventListener('mouseleave', () => drawing=false);

function toggleCursorPixel(){
  if (!canvas.width || !canvas.height) return;
  const blockWidth = Math.min(penSize, canvas.width - cursorX);
  const blockHeight = Math.min(penSize, canvas.height - cursorY);
  if (blockWidth <= 0 || blockHeight <= 0) return;

  const blockData = ctx.getImageData(cursorX, cursorY, blockWidth, blockHeight).data;
  let isEmpty = true;
  const bgRGB = transparentToggle.checked ? null : hexToRGB(bgColorInput.value);
  for (let i = 0; i < blockData.length; i += 4) {
    if (transparentToggle.checked) {
      if (blockData[i + 3] !== 0) {
        isEmpty = false;
        break;
      }
    } else {
      const matchesBg = blockData[i] === bgRGB.r && blockData[i + 1] === bgRGB.g && blockData[i + 2] === bgRGB.b && blockData[i + 3] === 255;
      if (!matchesBg) {
        isEmpty = false;
        break;
      }
    }
  }

  saveState();
  if (isEmpty) {
    ctx.fillStyle = penColor;
    ctx.fillRect(cursorX, cursorY, blockWidth, blockHeight);
  } else {
    if (transparentToggle.checked) {
      ctx.clearRect(cursorX, cursorY, blockWidth, blockHeight);
    } else {
      ctx.fillStyle = bgColorInput.value;
      ctx.fillRect(cursorX, cursorY, blockWidth, blockHeight);
    }
  }
}

function activeElementConsumesKeys(){
  const active = document.activeElement;
  if (!active) return false;
  if (active === document.body) return false;
  const tag = active.tagName;
  return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || tag === 'BUTTON' || active.isContentEditable;
}

window.addEventListener('keydown', e => {
  if (activeElementConsumesKeys()) return;
  if (e.repeat && (e.key === ' ' || e.key === 'Spacebar')) return;
  let handled = false;
  switch (e.key) {
    case 'ArrowUp':
      cursorY = clamp(cursorY - penSize, 0, Math.max(0, canvas.height - penSize));
      handled = true;
      break;
    case 'ArrowDown':
      cursorY = clamp(cursorY + penSize, 0, Math.max(0, canvas.height - penSize));
      handled = true;
      break;
    case 'ArrowLeft':
      cursorX = clamp(cursorX - penSize, 0, Math.max(0, canvas.width - penSize));
      handled = true;
      break;
    case 'ArrowRight':
      cursorX = clamp(cursorX + penSize, 0, Math.max(0, canvas.width - penSize));
      handled = true;
      break;
    case ' ': // Space
    case 'Spacebar':
      toggleCursorPixel();
      handled = true;
      break;
    default:
      break;
  }

  if (handled) {
    e.preventDefault();
    updateCursorOverlayPosition();
  }
});

// Undo / Reset / Export
const undoBtn = document.getElementById('undoBtn');
const resetBtn = document.getElementById('resetBtn');
const exportBtn = document.getElementById('exportBtn');

undoBtn.addEventListener('click', () => {
  if (!historyStack.length) return;
  const data = historyStack.pop();
  const img = new Image();
  img.onload = () => {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img,0,0);
  };
  img.src = data;
});

resetBtn.addEventListener('click', () => {
  const msg = "Hold up pixel wizard, this will vaporize your masterpiece into the digital void and give you a fresh, empty canvas. Proceed?";
  if (!confirm(msg)) return;

  // Hard clear: wipe pixels and history so nothing can be undone back
  clearCanvasContents();
  historyStack = [];
  uploadedImage = null;
});

exportBtn.addEventListener('click', () => {
  const exp = document.createElement('canvas');
  exp.width = canvas.width;
  exp.height = canvas.height;
  const ectx = exp.getContext('2d');
  if (!transparentToggle.checked) {
    ectx.fillStyle = bgColorInput.value;
    ectx.fillRect(0,0,exp.width,exp.height);
  }
  ectx.drawImage(canvas,0,0);
  const link = document.createElement('a');
  let name = fileNameInput.value.trim() || 'design';
  if (!name.toLowerCase().endsWith('.png')) name += '.png';
  link.download = name;
  link.href = exp.toDataURL('image/png');
  link.click();
});

uploadBtn.addEventListener('click', () => uploadInput.click());

uploadInput.addEventListener('change', e => {
  const file = e.target.files && e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = ev => {
    const img = new Image();
    img.onload = () => {
      uploadedImage = img;
      renderImageToCanvas(img);
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
  uploadInput.value = '';
});

bitifyBtn.addEventListener('click', () => {
  if (canvas.width === 0 || canvas.height === 0) return;
  eightBitifyCanvas();
});

if (colorPickerToolBtn) {
  colorPickerToolBtn.addEventListener('click', () => {
    setPickColorMode(!pickColorMode);
  });
}

window.addEventListener('keydown', e => {
  if (e.key === 'Escape' && pickColorMode) {
    setPickColorMode(false);
  }
});

// ==========================
// HSV Color Picker subsystem
// ==========================

function HSVtoRGB(h,s,v){
  let f = n => {
    let k = (n + h*6) % 6;
    return v - v*s*Math.max(Math.min(k,4-k,1),0);
  };
  return {
    r: Math.round(f(5)*255),
    g: Math.round(f(3)*255),
    b: Math.round(f(1)*255)
  };
}

function RGBtoHSV(r,g,b){
  r/=255; g/=255; b/=255;
  const max = Math.max(r,g,b), min = Math.min(r,g,b);
  const d = max-min;
  let h;
  const v = max;
  const s = max === 0 ? 0 : d/max;
  if (d === 0) h = 0;
  else if (max === r) h = ((g-b)/d + (g<b?6:0))/6;
  else if (max === g) h = ((b-r)/d + 2)/6;
  else h = ((r-g)/d + 4)/6;
  return {h,s,v};
}

function hexToRGB(hex){
  hex = hex.replace('#','');
  if (hex.length !== 6) return {r:255,g:255,b:255};
  return {
    r: parseInt(hex.slice(0,2),16),
    g: parseInt(hex.slice(2,4),16),
    b: parseInt(hex.slice(4,6),16)
  };
}

function RGBtoHex(r,g,b){
  return '#' + [r,g,b].map(v=>{
    const n = clamp(v,0,255)|0;
    return n.toString(16).padStart(2,'0');
  }).join('');
}

function drawHue(){
  if (!hueCtx || !hue) return;
  const grad = hueCtx.createLinearGradient(0,0,0,hue.height);
  grad.addColorStop(0,'#f00');
  grad.addColorStop(0.17,'#ff0');
  grad.addColorStop(0.33,'#0f0');
  grad.addColorStop(0.5,'#0ff');
  grad.addColorStop(0.67,'#00f');
  grad.addColorStop(0.83,'#f0f');
  grad.addColorStop(1,'#f00');
  hueCtx.fillStyle = grad;
  hueCtx.fillRect(0,0,hue.width,hue.height);
}

function drawSV(){
  if (!svCtx || !sv) return;
  const rgb = HSVtoRGB(hsv.h,1,1);
  let gradX = svCtx.createLinearGradient(0,0,sv.width,0);
  gradX.addColorStop(0,'#ffffff');
  gradX.addColorStop(1,`rgb(${rgb.r},${rgb.g},${rgb.b})`);
  svCtx.fillStyle = gradX;
  svCtx.fillRect(0,0,sv.width,sv.height);

  let gradY = svCtx.createLinearGradient(0,0,0,sv.height);
  gradY.addColorStop(0,'rgba(0,0,0,0)');
  gradY.addColorStop(1,'#000000');
  svCtx.fillStyle = gradY;
  svCtx.fillRect(0,0,sv.width,sv.height);
}

function updatePickerFields(){
  const rgb = HSVtoRGB(hsv.h,hsv.s,hsv.v);
  const hex = RGBtoHex(rgb.r,rgb.g,rgb.b);
  if (customHex) customHex.value = hex;
  if (rInput) rInput.value = rgb.r;
  if (gInput) gInput.value = rgb.g;
  if (bInput) bInput.value = rgb.b;
  updatePreviewSwatch(hex);

  // cursor positions
  if (svCursor && sv) {
    const x = clamp(hsv.s * sv.width, 0, sv.width);
    const y = clamp((1 - hsv.v) * sv.height, 0, sv.height);
    svCursor.style.left = x + 'px';
    svCursor.style.top  = y + 'px';
    svCursor.style.display = 'block';
  }

  if (hueCursor && hue) {
    const hy = clamp(hsv.h * hue.height, 0, hue.height);
    hueCursor.style.left = (hue.width / 2) + 'px';
    hueCursor.style.top  = hy + 'px';
    hueCursor.style.display = 'block';
  }
}

function openPicker(targetKey, swatch){
  if (!picker || !swatch) return;
  setPickColorMode(false);
  currentPickerTarget = targetKey; // 'bg' or 'pen'
  const rect = swatch.getBoundingClientRect();
  picker.style.left = rect.left + 'px';
  picker.style.top  = (rect.bottom + 4) + 'px';

  picker.style.display = 'block';

  const hex = targetKey === 'bg' ? bgColorInput.value : penColorInput.value;
  const rgb = hexToRGB(hex);
  hsv = RGBtoHSV(rgb.r,rgb.g,rgb.b);
  drawHue();
  drawSV();
  updatePickerFields();
}

function closePicker(){
  if (picker) {
    picker.style.display = 'none';
  }
  currentPickerTarget = null;
}

function currentHSVHex(){
  const rgb = HSVtoRGB(hsv.h,hsv.s,hsv.v);
  return RGBtoHex(rgb.r,rgb.g,rgb.b);
}

function updatePreviewSwatch(hex = currentHSVHex()){
  if (!previewSwatch) return;
  previewSwatch.style.backgroundColor = hex;
  previewSwatch.title = `Apply ${hex}`;
}

function setHSVFromSVEvent(e){
  if (!sv) return;
  const rect = sv.getBoundingClientRect();
  let x = clamp((e.clientX - rect.left) / rect.width, 0, 1);
  let y = clamp((e.clientY - rect.top) / rect.height, 0, 1);
  hsv.s = x;
  hsv.v = 1 - y;
  drawSV();
  updatePickerFields();
}

function setHSVFromHueEvent(e){
  if (!hue) return;
  const rect = hue.getBoundingClientRect();
  let y = clamp((e.clientY - rect.top) / rect.height, 0, 1);
  hsv.h = y;
  drawHue();
  drawSV();
  updatePickerFields();
}

if (sv) {
  sv.addEventListener('mousedown', e => {
    setHSVFromSVEvent(e);
    function move(ev){ setHSVFromSVEvent(ev); }
    function up(){ window.removeEventListener('mousemove',move); window.removeEventListener('mouseup',up); }
    window.addEventListener('mousemove',move);
    window.addEventListener('mouseup',up);
  });
}

if (hue) {
  hue.addEventListener('mousedown', e => {
    setHSVFromHueEvent(e);
    function move(ev){ setHSVFromHueEvent(ev); }
    function up(){ window.removeEventListener('mousemove',move); window.removeEventListener('mouseup',up); }
    window.addEventListener('mousemove',move);
    window.addEventListener('mouseup',up);
  });
}

// Hex and RGB field sync
if (customHex) {
  customHex.addEventListener('input', () => {
    let v = customHex.value.trim();
    if (!v.startsWith('#')) v = '#' + v;
    if (/^#([0-9A-Fa-f]{6})$/.test(v)){
      const rgb = hexToRGB(v);
      hsv = RGBtoHSV(rgb.r,rgb.g,rgb.b);
      drawHue();
      drawSV();
      updatePickerFields();
    }
  });
}

[rInput,gInput,bInput].filter(Boolean).forEach(inp => {
  inp.addEventListener('change', () => {
    const r = parseInt(rInput.value,10)||0;
    const g = parseInt(gInput.value,10)||0;
    const b = parseInt(bInput.value,10)||0;
    hsv = RGBtoHSV(r,g,b);
    drawHue();
    drawSV();
    updatePickerFields();
  });
});

// History
function pushHistory(color){
  if (!historyRow) return;
  const normalized = normalizeHex(color);
  historyColors = historyColors.filter(c => c !== normalized);
  historyColors.unshift(normalized);
  if (historyColors.length > 8) historyColors.pop();
  historyRow.innerHTML = '';
  historyColors.forEach(col => {
    const d = document.createElement('div');
    d.className = 'historySwatch';
    d.style.backgroundColor = col;
    d.addEventListener('click', () => {
      const rgb = hexToRGB(col);
      hsv = RGBtoHSV(rgb.r,rgb.g,rgb.b);
      drawHue();
      drawSV();
      updatePickerFields();
    });
    historyRow.appendChild(d);
  });
}

function applySelectedColor(){
  if (!currentPickerTarget) return;
  const hex = currentHSVHex();
  applyColorToTarget(currentPickerTarget, hex);
  closePicker();
}

if (applyColorBtn) {
  applyColorBtn.addEventListener('click', applySelectedColor);
}
if (previewSwatch) {
  previewSwatch.addEventListener('click', applySelectedColor);
}

if (cancelColorBtn) {
  cancelColorBtn.addEventListener('click', closePicker);
}

if (bgSwatch) {
  bgSwatch.addEventListener('click', () => openPicker('bg', bgSwatch));
}
if (penSwatch) {
  penSwatch.addEventListener('click', () => openPicker('pen', penSwatch));
}

// ============
// Initialization
// ============
setPenSize(penSizeInput.value);
updateCanvasSize();
updateCanvasBackground();

// load default image placeholder centered (optional; here we just clear)
clearCanvasContents();

</script>
</body>
</html>
